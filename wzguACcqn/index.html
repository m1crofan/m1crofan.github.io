<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>java编程基础(一) | m1cr0fan&#39;sBlog</title>
<link rel="shortcut icon" href="https://m1crofan.github.io/favicon.ico?v=1744119440243">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://m1crofan.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="java编程基础(一) | m1cr0fan&#39;sBlog - Atom Feed" href="https://m1crofan.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="认识变量
对java而言，有如下基本数据类型

整数：有4种整形byte/short/int/long；分别占1/2/4/8字节
小数：有两种类型float/double
字符类型：char，表示单个字符
真假类型：boolean，表示真假..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://m1crofan.github.io">
  <img class="avatar" src="https://m1crofan.github.io/images/avatar.png?v=1744119440243" alt="">
  </a>
  <h1 class="site-title">
    m1cr0fan&#39;sBlog
  </h1>
  <p class="site-description">
    
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              java编程基础(一)
            </h2>
            <div class="post-info">
              <span>
                2024-09-16
              </span>
              <span>
                32 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h3 id="认识变量">认识变量</h3>
<p>对java而言，有如下基本数据类型</p>
<ul>
<li>整数：有4种整形byte/short/int/long；分别占1/2/4/8字节</li>
<li>小数：有两种类型float/double</li>
<li>字符类型：char，表示单个字符</li>
<li>真假类型：boolean，表示真假。</li>
</ul>
<p>基本数据类型都有对应的数组类型，<strong>数组表示固定长度的同种数据类型的多条记录</strong>，比如：一个字符可以用一个char类型数据表示，一段文字可以用一个char数组表示。</p>
<p>java是面向对象的语言，除了基本数据类型，其他都是对象类型。世界万物都是由元素周期表组成的，基本数据类型就相当于化学中的基本元素，而对象就相当于世间万物。</p>
<p>为了操作数据，需要把数据存放到内存中。所谓内存在程序看来就像是一块有地址编号的连续空间，数据放到内存中的某个位置后，为了方便地找到和操作这个数据，需要给这个位置起一个名字。编程语言通过变量这个概念来表示这个过程。</p>
<p>声明一个变量，比如<code>int a</code>，其实就是在内存中分配了一块空间，这块空间存放int数据类型，a指向这块内存空间所在的位置，通过对a操作即可操作a指向的内存空间。之所以叫“变”量，是因为它表示的是内存中的位置，这个位置存放的值是可以变的。</p>
<p>虽然变量的值可以变化，但变量的名字是不变的，这个名字应该<strong>表示程序员心目中这块内存空间所存储内容的意义</strong>，<strong>这个意义是不变的</strong>。</p>
<h3 id="赋值">赋值</h3>
<p>整型</p>
<p>声明变量之后，就在内存分配了一块位置，但这个位置的内容是位置的，赋值就是把这块位置的内容设为一个确定的值。</p>
<p>赋值形式很简单，直接把熟悉的数字常量形式赋值给变量即可，对应的内存空间的值就从未知变成了确定的常量。</p>
<pre><code class="language-java">byte b = 23;
short s = 3333;
int i = 9999;
long l = 32323;
</code></pre>
<p>但，在给long类型赋值时，如果常量超过了int的表示范围，需要在常量后面加大写或小写L，例如：</p>
<pre><code class="language-java">long a = 323234343433L;
</code></pre>
<p>小数类型</p>
<p>对于double，直接把小数表示赋值给变量就可</p>
<pre><code class="language-java">double d = 333.33;
</code></pre>
<p>但对于float，需要在数字后面加大写字母F或小写字母f,例如：</p>
<pre><code class="language-java">float f = 333.33f;
</code></pre>
<p>这是由于小数常量默认是double类型。</p>
<p>除了小数，也可以把整数直接赋值给double或float；这很好理解：整数是特殊的小数。</p>
<p>真假类型</p>
<pre><code class="language-java">boolean b = true;
b = false;
</code></pre>
<p>字符类型</p>
<p>字符类型char用于表示一个字符，char占内存空间两个字节。赋值时把常量字符用单引号括起来。</p>
<pre><code class="language-java">char c = 'A';
</code></pre>
<p>数组类型</p>
<p>基本类型的数组有3种赋值形式</p>
<pre><code class="language-java">int[] arr = {1,2,3};//当变量赋值
int[] arr = new int[] {1,2,3};//当对象赋值
</code></pre>
<pre><code class="language-java">int[] arr = new int[3];//先定好长度，后赋值。
arr[0] = 1;
arr[1] = 2;
arr[2] = 3;
</code></pre>
<p>第一种和第二种都是预先知道数组的内容，而第三种是先分配长度，然后再给每个元素赋值。第三种形式中，即使没有给每个元素赋值，每个元素也都有一个默认值，这个默认值跟数组类型有关，数值类型的值为0，boolean为false，char为空字符。</p>
<p>数组的长度可以动态确定</p>
<pre><code class="language-java">int length = ...;//根据一些条件动态计算
int arr = new int[length];
</code></pre>
<p>数组长度虽然可以动态确定，<strong>但定了之后就不可以变</strong>。数组有一个length属性，但只能读，不能更改。还有一个小细节，不能在给定初始值的同时给定长度，即如下格式是不允许的：</p>
<pre><code class="language-java">int[] arr = new int[3]{1,2,3};
</code></pre>
<p>可以这么理解，因为初始值已经决定了长度，再给个长度，如果还不一致，计算机将无所适从。</p>
<p>数组类型和基本类型有明显不同的，一个基本类型变量，内存中只会有一块对应的内存空间。但数组有两块：一块用于存储数组内容本身，另一块用于存储内容的位置。用一个例子来说明，有一个int变量a，以及一个int数组变量arr，其代码、变量对应的内存地址和内存内容如下所示：</p>
<figure data-type="image" tabindex="1"><img src="https://raw.githubusercontent.com/m1crofan/image/main/image-20240916132530294.png" alt="image-20240916132530294" loading="lazy"></figure>
<p>基本类型a的内存地址是1000，这个位置存储的就是它的值100，数组类型arr的内存地址是2000，这个位置存储的值是一个位置3000，3000开始的位置存储的才是实际的数据“1，2，3”。</p>
<p>为什么数组要用两块要用两块空间？</p>
<pre><code class="language-java">int[] arrA = {1,2,3};
int[] arrB = {4,5,6,7};
arrA = arrB;
</code></pre>
<p>这段代码中，arrA初始长度是3X4个字节，arrB的初始长度是4X4个字节，后来将arrB的值赋给了arrA。如果arrA对应的内存空间是直接存储的数组内容，那么它将没有足够的空间去容纳arrB的所有元素。</p>
<p>用两块空间存储就简单得多，arrA存储的值就变成了和arrB的一样，存储的都是数组内容{4，5，6，7}<strong>的地址</strong>，此后访问arrA就和arrB是一样的了，而arrA{1，2，3}的内存空间由于不再被引用会进行垃圾回收。</p>
<p>由上也可以看出，给数组变量赋值和给数组中元素赋值是两回事，给数组中元素赋值是改变数组内容，而给数组变量赋值则会让变量指向一个不同的位置。</p>
<p>上面说数组的长度是不可以变的，不可变指的是数组的内容空间，一经分配，长度就不能再变了，但可以改变数组变量的值，它它指向一个长度不同的空间。</p>
<h3 id="基本运算">基本运算</h3>
<p>java中基本类型数据的主要运算有：</p>
<ul>
<li>算术运算：日常的加减乘除。</li>
<li>比较运算：日常的大小比较。</li>
<li>逻辑运算：针对布尔值进行运算。</li>
</ul>
<p>算数运算符有加、减、乘、除，符号分别是+、-、*、/，另外还有取模运算符%，以及自增（++）和自减（--）运算符。<strong>取模运算适用于整数和字符类型，其他算术运算适用于所有数值类型和字符类型</strong>。大部分运算都符合我们的数学常识。但，字符怎么也可以进行算术运算？这个后面会讲。</p>
<ul>
<li>减号用于两个数相减，也可以放在一个数前面用来表示负数。</li>
<li>取模(%)就是<strong>数学中的求余数</strong>，例如，5%3是2，10%9是1。</li>
<li>自增(++)和自减(--)，是一种快捷方式，是对自己进行加1或减1操作。</li>
</ul>
<p>加减乘除大部分情况和数学运算是一样的，都很容易理解，但有一些需要注意的地方，而自增、自减稍微复杂一些。</p>
<p>运算时要注意结果的范围，使用恰当的数据类型。两个整数都可以用int表示，但相乘的结果可能就会超出：</p>
<pre><code class="language-java">int a = 2147483647*2; //2147483647是int能表示的最大值
</code></pre>
<p>a的结果是-2。要避免这样的情况，我们的结果类型应使用long，但只改为long也是不够的，因为运算还是默认按照int类型进行，需要将至少一个数据表示为long形式，即在后面加L或l。</p>
<pre><code class="language-java">long a = 2147483647*2L;
</code></pre>
<p>另外，需要注意的是，整数相除不是四舍五入，而是直接舍去小数位</p>
<pre><code class="language-java">double d = 10/4;
</code></pre>
<p>结果是2而不是2.5，如果要按小数进行运算，需要将至少一个数表示为小数形式，或者使用强制类型转换，即在数字前面加(double),表示将数字看作double类型</p>
<pre><code class="language-java">double d = 10/4.0;
double d = 10/(double)4;
</code></pre>
<p>无论使用float还是double，进行运算时都会出现一些非常令人困惑的现象，比如：</p>
<pre><code class="language-java">float f = 0.1f*0.1f;
System.out.println(f);
</code></pre>
<p>这个结果看上去应该是0.01，但实际上，屏幕输出却是0.010000001，后面多了个1。换用double看看：</p>
<pre><code class="language-java">double d = 0.1*0.1;
System.out.println(d);
</code></pre>
<p>屏幕输出0.010000000000000002，一连串的0后多了个2。<strong>这是为什么呢？会在后面学习！</strong></p>
<p><strong>自增/自减</strong></p>
<p>自增/自减是对自己做加1减1操作，但每个都有两种形式，一种是放在变量后，例如a++、a--，另一种是放在变量前，例如++a、--a。</p>
<p>如果只是对自己操作，这两种形式没差，区别在于还有其他操作的时候。放在变量后(a++)是先用原来的值进行其他操作，再对自己进行修改，而放在变量前(++a)是先对自己修改，再用修改的值做其他操作。</p>
<table>
<thead>
<tr>
<th>快捷运算</th>
<th>等同运算</th>
</tr>
</thead>
<tbody>
<tr>
<td>b=a++-1</td>
<td>b=a-1 ; a=a+1</td>
</tr>
<tr>
<td>c=++a-1</td>
<td>a=a+1; c=a</td>
</tr>
<tr>
<td>arrA[i++]=arrB[++j]</td>
<td>j=j+1;arrA[i]=arrB[j];i=i+1</td>
</tr>
</tbody>
</table>
<p><strong>比较运算</strong></p>
<p>比较运算就是计算两个值之前的关系，结果是一个布尔类型的值。比较运算适用于所有数值类型和字符类型。</p>
<p>比较运算有大于(&gt;)、大于等于(&gt;=)、小于(&lt;)、小于等于(&lt;=)、等于(==)、不等于(!=)。</p>
<p>需要注意的是，对于数组，<strong>==判断的是两个变量指向的是不是同一个数组</strong>，而不是两个数组的元素内容是否一样，即使两个数组的内容一样，但如果两个不同的数组，==依然会返回false</p>
<pre><code class="language-java">int[] a = new int[] {1,2,3};
int[] b = new int[] {1,2,3};
//a==b 的结果是false
</code></pre>
<p>如果需要比较数组的内容是否一样，需要逐个比较里面存储的每个元素。</p>
<p><strong>逻辑运算</strong></p>
<ul>
<li>与(&amp;): 两个都为true才是true，只要有一个是false就是false。</li>
<li>或(|):只要有一个为true就是true，都是false才是false。</li>
<li>非(!): 针对一个变量，true会变成false，false会变成true。</li>
<li>异或(^): 两个相同为false，两个不同为true；</li>
<li>短路与(&amp;&amp;): 和&amp;类似</li>
<li>短路或(||): 与|类似</li>
</ul>
<p>逻辑运算的大部分都是比较直观的，需要注意的是&amp;和&amp;&amp;，以及|和||的区别。如果只是进行逻辑运算，它们也都是相同的，区别在于同时有其他操作的情况下</p>
<pre><code class="language-java">boolean a = true;
int b = 0;
boolean flag = a | b++ &gt;0;
</code></pre>
<p>因为a为true，所以flag也为true，但b的结果为1，因为|后面的式子也会进行运算，即使只看a已经知道flag的结果，还是会进行后面的运算。而||则不同，如果最后一句的代码是：</p>
<pre><code class="language-java">boolean flag = a || b++ &gt;0;
</code></pre>
<p>则b的值还是0， 因为||会“短路”，即再看到||前面部分就可以判定结果的情况下会忽略后面的运算。</p>
<p>那如果我们把a的值换成false呢？结果是false 0；还是false 1 ？</p>
<p>这个问题很有意思，结果是false 1；</p>
<pre><code class="language-java">boolean a = false;
int b = 0;
boolean flag = a || b++ &gt;0;
</code></pre>
<p>显然，当a不是false，就不会忽略后面的运算了；可后面不是++b，而是b++;即：先进行其他操作，再自增，所以结果是false 1。</p>
<pre><code class="language-java">boolean a = false;
int b = 0;
boolean flag = a || ++b &gt;0;
</code></pre>
<p>那么，这个返回什么呢？</p>
<p>答案：ture 、1。</p>
<p>因为这次是++b,先自增后进行其他操作。</p>
<h3 id="条件执行">条件执行</h3>
<p>流程控制中最基本的就是条件执行，一些操作只能在某些条件满足的情况下才执行，在一些条件下执行某些操作，在另一些条件下执行另外的操作。</p>
<p>java中表达条件执行的基本语法是if语句，它的语法是：</p>
<pre><code class="language-java">if(条件语句){
    代码块
}
</code></pre>
<p>或</p>
<pre><code class="language-java">if(条件语句) 代码;
</code></pre>
<p>表达的含义也非常简单，只有在条件语句为真的情况下，才执行后面的代码，为假就不执行了。具体来说，条件语句必须为布尔值，可以是一个直接的布尔变量，也可以是变量运算后的结果。如果条件语句为true，则执行括号{}中的代码，如果后面没有括号，则执行后面第一个分号；前的代码。</p>
<p>比如，只在变量为偶数的情况下输出：</p>
<pre><code class="language-java">int a = 10;
if(a%2 == 0){
    System.out.println(&quot;偶数&quot;)
}
</code></pre>
<p>或者：</p>
<pre><code class="language-java">int a = 10;
if(a%2==0) System.out.println(&quot;偶数&quot;)；
</code></pre>
<p>if实现的是条件满足的时候做什么操作，如果需要根据条件做分支，即满足的时候执行某种逻辑，而不满足的时候执行另一种逻辑，则可以用if/else</p>
<pre><code class="language-java">if(判断条件){
    代码块1
}else{
    代码块2
}
</code></pre>
<p>三元运算符的语法为：</p>
<pre><code class="language-java">判断条件 ? 表达式1 : 表达式2
</code></pre>
<p>三元运算符会得到一个结果，判断条件为真的时候就返回表达式1的值，否则就返回表达式2的值。三元运算符经常用于对某个变量赋值，例如求两个数的最大值：</p>
<pre><code class="language-java">int max = x &gt; y ? x:y;
</code></pre>
<p>三元运算符完全可以用if/else代替，但三元运算符的书写方式更简洁。</p>
<p>如果有多个判断条件，而且需要根据这些判断条件的组合执行某些操作，则可使用if / else if / else 语法如下：</p>
<pre><code class="language-java">if(条件1){
    代码块1
}else if(条件2){
    代码块2
}...
else if(条件n){
    代码块n
}else{
    代码块n+1
}
</code></pre>
<p>if / else if / else: 需要注意的是，判断顺序很重要，后面的判断<strong>只有在前面的条件为false的时候才会执行</strong>。</p>
<p>如下面这个代码：</p>
<pre><code class="language-java">if(score&gt;60){
    return &quot;及格&quot;;
}else if(score &gt;80){
    return &quot;良好&quot;;
}else{
    return &quot;优秀&quot;;
}
</code></pre>
<p>这段代码乍一看，似乎没什么问题；如果score是90，期望返回“优秀”，但实际只会返回“及格”。</p>
<p>在if /else if /else中，如果判断的条件基于的是同一个变量，只是根据变量值的不同而有不同的分支，如果值比较多，比如根据星期几进行判断，有7种可能性，或者根据英文字母进行判断，有26种可能性，使用if/ else if /else 比较繁琐，这种情况就可以使用switch：</p>
<pre><code class="language-java">switch(表达式){
    case 值1:
        代码1; break;
    case 值2:
        代码2; break;
    ...
    case 值n:
        代码n; break;
    default: 代码n+1
}
</code></pre>
<p>switch也比较简单，根据表达式的值执行不同的分支，具体来说，根据表达式的值找匹配的case，找到后执行后面的语句。**表达式值得数据类型只能是byte、short、int、char、枚举和String。**枚举和String后面会介绍。关键词break是指跳出switch语句，执行switch后面得语句。</p>
<p>从逻辑上讲，if/else 、 if/else if/else、三元运算符、switch都可以只用if代替，但使用不同得语句表达更简洁，在条件比较多的时候，switch从性能上看也更高。</p>
<p><strong>条件执行的实现原理</strong></p>
<p>条件执行具体是怎么实现的呢？程序最终都是一条条的指令，CPU有一个指令指示器，指向下一条要执行的指令，CPU根据指示器的指示加载指令并且执行。指令大部分是具体的操作和运算，在执行这些操作时，执行完一个操作后，指令指示器会自动指向挨着的下一条指令。</p>
<p>但有一些特殊的指令，称为跳转指令，这些指令会修改指令指示器的值，让CPU跳到一个指定的地方指向。跳转有两种：一种是条件跳转；一种是无条件跳转。条件跳转检查某个条件，满足则进行跳转，无条件跳转则是直接进行跳转。</p>
<p>if/else实际上会转换为这些跳转指令，比如：</p>
<pre><code class="language-java">int a = 10;
if (a%2 == 0)
{
    System.out.println(&quot;偶数&quot;);
}
//其他代码
</code></pre>
<p>抓换到的转移指令可能是：</p>
<pre><code class="language-java">int a = 10;
条件跳转：如果a%2==0，跳转到第四行
无条件跳转：跳转到第七行
{
    System.out.println(&quot;偶数&quot;);
}
//其他代码
</code></pre>
<p>你可能会奇怪第3行的无条件跳转指令，没有它不行吗？不行，没有这条指令，它会顺序执行接下来的指令，导致不管什么条件，括号中的代码都会执行。不过对应的跳转指令也可能是：</p>
<pre><code class="language-java">int a = 10;
条件跳转：如果a%2!= 0,跳转到第六行
{
    System.out.ptintln(&quot;偶数&quot;);
}
//其他代码
</code></pre>
<p>这里就没有无条件跳转指令，具体怎么对应和编译器实现有关。在单一if的情况下可能不用无条件跳转指令，但稍微复杂一些的情况都需要。if、if/else、if/else if/else、三元运算都会转换为条件跳转和无条件跳转，但swich不太一样。</p>
<p>switch的转换和具体系统系统实现有关，如果分支比较少，可能会转换为跳转指令。如果分支比较多，使用条件跳转会进行很多次的比较运算，效率比较低，可能会使用一种更为高效的方式，叫跳转表。跳转表是一个映射表，存储了可能的值以及要跳转到的地址。</p>
<table>
<thead>
<tr>
<th>条件值</th>
<th>跳转地址</th>
<th>条件值</th>
<th>跳转地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>值1</td>
<td>代码块1的地址</td>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>值2</td>
<td>代码块2的地址</td>
<td>值n</td>
<td>代码块n的地址</td>
</tr>
</tbody>
</table>
<p>跳转表之所以高效，是因为其中的值必须为整数，且按大小顺序排序。按大小排序的整数可以使用高效的二分查找。如果值是连续的，则跳转表还会进行特殊优化，优化为一个数组，连找都不用找了，值就是数组的下标索引，直接根据值就可以找到跳转的地址。即使值不是连续的，但数字比较密集，差的不多，编译器也可能会优化为一个数组型的跳转表，没有的值指向default分支。</p>
<p>程序源代码中的casr值排列不要求是排序的，编译器会自动排序。之前说switch值的类型可以是byte、short、int、char、枚举和string。其中byte/short/int本来就是整数，char本质上也是整数，而枚举类型也有对应的整数（这个后面会学），String用于switch时也会转换为整数。不可以使用long，因为跳转表值得存储空间为32位，容不下long。简单说明下String，String是通过hashCode方法转换为整数的，但不同String的hashCode可能相同，跳转后会再次根据String的内容进行比较判断。</p>
<p><strong>循环</strong></p>
<p>在java中，循环有四种形式，分别是while、do/while、for和foreach，下面分别介绍</p>
<p>while的语句</p>
<pre><code class="language-java">while(条件语句){
    代码块
}
</code></pre>
<p>while和if的语法很像，只是把if换成了while，它表达的含义也非常简单，只要条件语句为真，就一直执行后面的代码，为假就停止不做了。比如</p>
<pre><code class="language-java">Scanner reader = new Scanner(System.in);
System.out.println(&quot;please input password&quot;);
int num = reader.nextInt();
int password = 6789;
while(num!=password){
    System.out.println(&quot;please input password&quot;);
}
System.out.println(&quot;correct&quot;);
reader.close();
</code></pre>
<p>以上代码中，我们使用类型为Scanner的reader变量从屏幕控制台接收数字，reader.nextInt()从屏幕接收一个数字，如果数字不是6789，就一直提示输入，否则跳出循环。</p>
<p>while循环中，代码块中会有影响循环中断或退出的条件，但经常不知道什么时候循环会中断或退出。</p>
<p>do/while</p>
<p>不管条件语句是什么，代码块都会至少执行一次</p>
<pre><code class="language-java">do{
    代码块;
}while(条件语句)
</code></pre>
<p>for</p>
<p>实际中应用最为广泛的循环语法可能是for了，尤其是在循环次数已知的情况。语法为：</p>
<pre><code class="language-java">for(初始化语句;循环条件;步进操作){
    循环体
}
</code></pre>
<p>for后面的括号中有两个分号；分隔了三条语句。除了循环条件必须返回一个boolean类型外，其他语句没有什么要求，但通常情况下第一条语句用于初始化，尤其是循环的索引变量，第三条语句修改循环变量，一般是步进，即递增或递减索引变量，循环体是在循环中执行的语句。</p>
<p>它的执行流程如下：</p>
<ol>
<li>执行初始化指令；</li>
<li>检查循环条件是否为true，如果为false，则跳转到第六步；</li>
<li>循环条件为真，执行循环体；</li>
<li>执行步进操作；</li>
<li>步进操作执行完后，跳转到第二步，即继续检查循环条件；</li>
<li>for循环后面的语句；</li>
</ol>
<p>下面是一个简单的for循环</p>
<pre><code class="language-java">int[] arr = {1,2,3,4};
for(int i=0; i&lt;arr.length; i++){
    System.out.println(arr[i]);
}
</code></pre>
<p>顺序打印数组中的每个元素，初始化语句初始化索引i为0，循环条件为索引雄安与数组长度，步进操作为递增索引i，循环体打印数组元素。</p>
<p>在for中，每条语句都是可以为空的，也就是</p>
<pre><code class="language-java">for( ; ; ){}
</code></pre>
<p>是有效的，这是一个死循环。注意:可以省略语句，但分号不能省。</p>
<p>foreach</p>
<p>我们来看一个foreach的例子</p>
<pre><code class="language-java">int[] arr = {1,2,3,4};
for(int element : arr){
    System.out.println(element);
}
</code></pre>
<p>foreach不是一个关键字，它使用冒号：，冒号前面是循环中的每个元素，包括数据类型和变量名称，冒号后面是要遍历的数组或集合，每次循环element都会自动更新。对于不需要使用索引变量，只是简单遍历的情况，foreach语法上会更简洁。</p>
<p>在循环中，会以循环条件作为是否结束的依据，但有时可能会需要根据别的条件提前结束循环或跳过一些代码，这时候可以使用break或continue关键字对循环进行控制。</p>
<p>break</p>
<p>break用于提前结束循环。比如，在一个数组中查找某个元素时，循环条件可能是到数组结束，但如果找到了元素，可能就会想提前结束循环，这时候就可以使用break。</p>
<pre><code class="language-java">int[] arr = ...; //在该数组中查找元素
int toSearch = 100; //要查找的元素
int i = 0;
for(;i&lt;arr.length;i++){
    if(arr[i]==toSearch){
        break;
    }
}
if(i!=arr.length){
    System.out.println(&quot;found&quot;);
}else{
    System.out.println(&quot;not found&quot;);
}
</code></pre>
<p>continue</p>
<pre><code class="language-java">int[] arr = ... //在该数组中查找元素
int toSearch = 2; //要查找的元素
int count = 0;
for(int i=0; i&lt;arr.length; i++){
    if(arr[i] != toSearch){
        continue;
    }
    count++;
}
System.out.println(&quot;found count&quot;+count);
</code></pre>
<p>上面代码统计数组中值等于toSearch的元素个数，如果值不等于toSearch，<strong>则跳过剩下的循环代码</strong>，执行i++。以上代码也可以不用continue，使用相反的if判断也可以得到相同的结果。</p>
<h3 id="函数">函数</h3>
<p>函数这个概念，我们学数学的时候都接触过，其基本格式是y=f(x),表示的是x到y的对应关系，给定输入x，经过函数变换f，输出y。程序中的函数概念与其类似，也由输入、操作和输出组成，但它表示的是一段子程序，这个子程序有一个名字，表示它的目的(类比f)，有零个或多个参数(类比于x)，有可能返回一个结果。下面是一个函数的例子：</p>
<pre><code class="language-java">public static int sum(int a, int b){
    int sum = a + b;
    return sum;
}
public static void print3Lines(){
    for(int i=0 ; i &lt; 3 ; i++){
        System.out.println();
    }
}
</code></pre>
<p>第一个函数名叫sum，它的目的是对输入的两个数求和。有两个输入参数，分别是int整数a和b，它的操作是对两个数求和，求和结果放在变量sum中。然后使用return语句将结果返回，最开始的public static是函数修饰符，后续介绍。</p>
<p>第二个函数名字叫print3Lines，它的目的是在屏幕上输出三个空行，它没有输入参数，操作是使用一个循环输出三个空行，它没有返回值。</p>
<p>函数的基本结构如下：</p>
<pre><code class="language-java">修饰符 返回值类型 函数名字(参数类型 参数名字, ...){
    操作;
    return 返回值;
}
</code></pre>
<ul>
<li>函数名字：名字是不可或缺的，表示函数的功能。</li>
<li>参数：参数有0个到多个，每个参数由参数的数据类型和参数名字组成。</li>
<li>操作：函数的具体操作代码。</li>
<li>返回值: 函数可以没有返回值，如果没有返回值则类型写成void,如果有则在函数代码中必须使用return语句返回一个值，这个值的类型需要和声明的返回值类型一致。</li>
<li>修饰符：暂时不介绍，后面介绍</li>
</ul>
<p>以上就是函数的语法，定义函数就是定义了一段有着明确功能的子程序，但定义函数本身不会执行任何代码，函数要被执行，需要被调用。</p>
<p>java中，任何函数都需要放在一个类中。类还没有介绍，我们暂时可以把类看作函数的一个容器。即函数放在类中，类中包含多个函数(方法)。类里面可以定义一个叫做main的方法，形式如下：</p>
<pre><code class="language-java">public static void main(String[] args){
    ...
}
</code></pre>
<p>这个函数有特殊的含义，表示程序的入口，String[] args表示从控制台接收到的参数，我们暂时可以忽略它。Java运行一个程序的时候，需要指定一个定义了main函数的类，java会寻找main函数，并从main函数开始执行。</p>
<p>关于参数传递，简单总结一下，定义函数时声明参数，无论是形参，还是返回值，实际上就是在定义变量，只是这些变量的值是未知的。调用函数时传递参数，实际上就是给函数中的变量赋值。</p>
<p>我们知道，程序执行基本只有顺序执行、条件执行和循环执行，但更完整的描述应该包括函数的调用过程。程序从main函数开始执行，碰到函数调用的时候，会跳转进函数内部，返回到main函数并且main函数没有要执行的语句后程序结束。</p>
<p>参数传递有两类特殊类型的参数：数组和可变长度的参数。</p>
<p>(1)数组</p>
<p>数组作为参数与基本类型是不一样的，基本类型不会对调用者中的变量造成任何影响，但数组不是，在函数内修改数组中的元素会修改调用者中的数组内容。我们看这个例子：</p>
<pre><code class="language-java">public static void reset(int[] arr){
    for(int i=0; i&lt;arr.length; i++){
        arr[i] = i;
    }
}

public static void main(String[] args){
    int[] arr = {10,20,30,40};
    reset(arr);
    for(int i=0; i &lt; arr.length ; i++){
        System.out.println(arr[i])
    }
}
</code></pre>
<p>在reset函数内给参数数组元素赋值，在main函数中数组arr的值也会变。</p>
<p>这个其实也容易理解，一个数组变量有两块空间，一块用于存储数组内容本身，一块用于存储内容的位置，<strong>给数组变量赋值不会影响原有的数组内容，而只会让数组变量指向一个不同的数组内容空间。</strong></p>
<p>在上例中，函数参数中的数组变量arr和main函数中的数组变量arr存储的都是相同的位置，而数组内容本身只有一份数据，所以，在reset中修改数组元素内容和在main中修改是完全一样的。</p>
<p>前面介绍的函数，参数个数都是固定的，但有时候可能希望个数不是固定的，比如求若干个数的最大值，可能是两个，也可能是多个。java支持可变长度参数如下：</p>
<pre><code class="language-java">public static int max(int min, int ... a){
    int max = min;
    for (int i=0; i&lt; a.length; i++){
        if(max&lt;a[i]){
            max = a[i];
        }
    }
    return max;
}
public static void main(String[] args){
    System.out.println(max(0));
    System.out.println(max(0,2));
    System.out.println(max(0,2,4));
    System.out.println(max(0,2,4,5));
}
</code></pre>
<p>这个max函数接受一个最小值，以及可变长度的若干参数，返回其中的最大值。可变长度参数的语法是在数据类型后面加三个点&quot;...&quot;,在函数内，可变长度参数可以看作是数组。<strong>可变长度参数必须是参数列表中的最后一个，一个函数也只能有一个可变长度的参数。</strong></p>
<p>可变长度参数实际上会转换为数组参数，也就是说，函数声明max(int min,int... a)实际上会转换为max(int min, int[] a)。</p>
<p><strong>理解返回</strong></p>
<p>return用于显式结束函数执行，返回调用方。return可以用于函数内的任意地方，可以在函数结尾，也可以在中间，可以在if语句内，可以在for循环内，用于提前结束函数执行，返回调用方。</p>
<p>函数返回值类型为void也可以使用return，即&quot;return;&quot;,不用带值，含义是返回调用方，只是没有返回值而已。</p>
<p>函数的返回值最多只能有一个，那如果实际情况需要多个返回值呢？比如，计算一个整数数组中的最大的前三个数，需要返回三个结果。这个可以用数组作为返回值，在函数内创建一个包含三个元素的数组，然后将前三个结果赋给对应的数组元素。</p>
<p>如果实际情况需要的返回值是一种复合结果呢？比如，查找一个字符数组中所有重复出现的字符以及重复出现的次数，这个可以用对象作为返回值。总之，虽然返回值最多只能有一个，但其实一个就够了。</p>
<p>每个函数都有一个名字，这个名字表示这个函数的意义。名字可以重复吗？在不同类里，答案是肯定的，在同一类里，要看情况。</p>
<p>同一个类里，函数可以重名，但是参数不能完全一样，即要么参数个数不同，要么参数个数相同但至少有一个参数类型不一样。</p>
<blockquote>
<p>我问：在java中，在同一类中的两个同名函数仅返回值类型不同，形参类型、个数都相同；这种属于符合语法规则的重载函数吗？</p>
<p>AI回答：在Java中，函数的重载（Overloading）是指在同一类中可以有多个同名的方法，但是这些方法的参数列表必须有所不同（即参数的数量、类型或顺序不同）。根据这个定义，如果两个方法仅仅是返回值类型不同，而参数列表完全相同的话，那么这并不符合Java中方法重载的规则。<br>
具体来说，方法的重载与返回类型无关，只取决于参数列表的不同。因此，如果你在同一类中有两个同名方法，它们的参数列表完全一样，只是返回类型不同，编译器会报错，因为它无法区分这两个方法，这不符合Java的方法重载语法规则。</p>
</blockquote>
<p>同一个类中函数名相同但参数不同的现象，一般称为函数重载。</p>
<p>比如，在JAVA的Math库中就定义了4个函数，如下所示：</p>
<pre><code class="language-java">public static double max(double a, double b)
public static float max(float a, float b)
public static int max(int a, int b)
public static long max(long a, long b)
</code></pre>
<p>在之前介绍函数调用的时候，我们没有特别说明参数的类型。这里说明一下，参数传递实际上是给参数赋值，调用者传递的数据需要与函数声明的参数类型是匹配的，但不要求完全一样。什么意思呢？ java编译器会自动进行类型转换，并寻找到最匹配的函数，比如：</p>
<pre><code class="language-java">char a = 'a';
char b = 'b';
System.out.println(Math.max(a,b));
</code></pre>
<p>参数是字符类型的，但Math并没有定义针对字符类型的max函数，这是因为char其实是一个整数，java会自动将char转换为int，然后调用。</p>
<p>如果Math中没有定义针对int类型的max函数呢？调用也会成功，会调用long类型的max函数。如果long也没有呢？会调用float型的max函数。如果float也没有，会调用double型的。</p>
<p><strong>递归函数</strong></p>
<p>函数大部分情况下都是被别的函数调用的，但其实函数也可以调用它自己，调用自己的函数叫递归函数。我们来看一个例子，求一个数的阶乘，数学中一个数n的阶乘，表示为n！，它的值定义是这样的：</p>
<pre><code class="language-java">0!=1
n!=(n-1)!xn
</code></pre>
<p>这个定义是一个递归的定义，为求n的值，需先求n-1的值，直到0，然后依次往回退。</p>
<pre><code class="language-java">public static long factorial(int n){
    if(n==0){
        return 1;
    }else{
        return n*factorial(n-1)
    }
}
</code></pre>
<p>看上去比较容易，和数学定义类型。递归函数形式上往往比较简单，但递归函数有开销的，而且使用不当，可能会出现意外的情况。</p>
<pre><code class="language-java">System.out.println(factorial(100000));
</code></pre>
<p>系统不会给出任何结果，而会抛出异常。</p>
<p>递归不可行的情况下怎么办呢？ 递归函数经常可以转换为非递归函数的形式，通过循环实现。比如，求阶乘的例子，其非递归形式的定义是：</p>
<pre><code class="language-java">n! = 1x2x3x4x5x6...xn
</code></pre>
<p>这个可以用循环来实现</p>
<pre><code class="language-java">public static long factorial(int n){
    long result = 1;
    for(int i=1 ; i &lt;= n ; i++){
        result =result*i;
    }
    return result;
}
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E8%AE%A4%E8%AF%86%E5%8F%98%E9%87%8F">认识变量</a></li>
<li><a href="#%E8%B5%8B%E5%80%BC">赋值</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97">基本运算</a></li>
<li><a href="#%E6%9D%A1%E4%BB%B6%E6%89%A7%E8%A1%8C">条件执行</a></li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://m1crofan.github.io/DGqa3C2U_/">
              <h3 class="post-title">
                Frp内网穿透
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script>
<script>
    // md5.min.js
    !function(n){
        "use strict";
        function d(n,t){var r=(65535&n)+(65535&t);return(n>>16)+(t>>16)+(r>>16)<<16|65535&r}
        function f(n,t,r,e,o,u){return d((c=d(d(t,n),d(e,u)))<<(f=o)|c>>>32-f,r);var c,f}
        function l(n,t,r,e,o,u,c){return f(t&r|~t&e,n,t,o,u,c)}
        function v(n,t,r,e,o,u,c){return f(t&e|r&~e,n,t,o,u,c)}
        function g(n,t,r,e,o,u,c){return f(t^r^e,n,t,o,u,c)}
        function m(n,t,r,e,o,u,c){return f(r^(t|~e),n,t,o,u,c)}
        function i(n,t){var r,e,o,u,c;n[t>>5]|=128<<t%32,n[14+(t+64>>>9<<4)]=t;var f=1732584193,i=-271733879,a=-1732584194,h=271733878;for(r=0;r<n.length;r+=16)f=l(e=f,o=i,u=a,c=h,n[r],7,-680876936),h=l(h,f,i,a,n[r+1],12,-389564586),a=l(a,h,f,i,n[r+2],17,606105819),i=l(i,a,h,f,n[r+3],22,-1044525330),f=l(f,i,a,h,n[r+4],7,-176418897),h=l(h,f,i,a,n[r+5],12,1200080426),a=l(a,h,f,i,n[r+6],17,-1473231341),i=l(i,a,h,f,n[r+7],22,-45705983),f=l(f,i,a,h,n[r+8],7,1770035416),h=l(h,f,i,a,n[r+9],12,-1958414417),a=l(a,h,f,i,n[r+10],17,-42063),i=l(i,a,h,f,n[r+11],22,-1990404162),f=l(f,i,a,h,n[r+12],7,1804603682),h=l(h,f,i,a,n[r+13],12,-40341101),a=l(a,h,f,i,n[r+14],17,-1502002290),f=v(f,i=l(i,a,h,f,n[r+15],22,1236535329),a,h,n[r+1],5,-165796510),h=v(h,f,i,a,n[r+6],9,-1069501632),a=v(a,h,f,i,n[r+11],14,643717713),i=v(i,a,h,f,n[r],20,-373897302),f=v(f,i,a,h,n[r+5],5,-701558691),h=v(h,f,i,a,n[r+10],9,38016083),a=v(a,h,f,i,n[r+15],14,-660478335),i=v(i,a,h,f,n[r+4],20,-405537848),f=v(f,i,a,h,n[r+9],5,568446438),h=v(h,f,i,a,n[r+14],9,-1019803690),a=v(a,h,f,i,n[r+3],14,-187363961),i=v(i,a,h,f,n[r+8],20,1163531501),f=v(f,i,a,h,n[r+13],5,-1444681467),h=v(h,f,i,a,n[r+2],9,-51403784),a=v(a,h,f,i,n[r+7],14,1735328473),f=g(f,i=v(i,a,h,f,n[r+12],20,-1926607734),a,h,n[r+5],4,-378558),h=g(h,f,i,a,n[r+8],11,-2022574463),a=g(a,h,f,i,n[r+11],16,1839030562),i=g(i,a,h,f,n[r+14],23,-35309556),f=g(f,i,a,h,n[r+1],4,-1530992060),h=g(h,f,i,a,n[r+4],11,1272893353),a=g(a,h,f,i,n[r+7],16,-155497632),i=g(i,a,h,f,n[r+10],23,-1094730640),f=g(f,i,a,h,n[r+13],4,681279174),h=g(h,f,i,a,n[r],11,-358537222),a=g(a,h,f,i,n[r+3],16,-722521979),i=g(i,a,h,f,n[r+6],23,76029189),f=g(f,i,a,h,n[r+9],4,-640364487),h=g(h,f,i,a,n[r+12],11,-421815835),a=g(a,h,f,i,n[r+15],16,530742520),f=m(f,i=g(i,a,h,f,n[r+2],23,-995338651),a,h,n[r],6,-198630844),h=m(h,f,i,a,n[r+7],10,1126891415),a=m(a,h,f,i,n[r+14],15,-1416354905),i=m(i,a,h,f,n[r+5],21,-57434055),f=m(f,i,a,h,n[r+12],6,1700485571),h=m(h,f,i,a,n[r+3],10,-1894986606),a=m(a,h,f,i,n[r+10],15,-1051523),i=m(i,a,h,f,n[r+1],21,-2054922799),f=m(f,i,a,h,n[r+8],6,1873313359),h=m(h,f,i,a,n[r+15],10,-30611744),a=m(a,h,f,i,n[r+6],15,-1560198380),i=m(i,a,h,f,n[r+13],21,1309151649),f=m(f,i,a,h,n[r+4],6,-145523070),h=m(h,f,i,a,n[r+11],10,-1120210379),a=m(a,h,f,i,n[r+2],15,718787259),i=m(i,a,h,f,n[r+9],21,-343485551),f=d(f,e),i=d(i,o),a=d(a,u),h=d(h,c);return[f,i,a,h]}
        function a(n){var t,r="",e=32*n.length;for(t=0;t<e;t+=8)r+=String.fromCharCode(n[t>>5]>>>t%32&255);return r}
        function h(n){var t,r=[];for(r[(n.length>>2)-1]=void 0,t=0;t<r.length;t+=1)r[t]=0;var e=8*n.length;for(t=0;t<e;t+=8)r[t>>5]|=(255&n.charCodeAt(t/8))<<t%32;return r}
        function e(n){var t,r,e="0123456789abcdef",o="";for(r=0;r<n.length;r+=1)t=n.charCodeAt(r),o+=e.charAt(t>>>4&15)+e.charAt(15&t);return o}
        function r(n){return unescape(encodeURIComponent(n))}
        function o(n){return a(i(h(t=r(n)),8*t.length));var t}
        function u(n,t){return function(n,t){var r,e,o=h(n),u=[],c=[];for(u[15]=c[15]=void 0,16<o.length&&(o=i(o,8*n.length)),r=0;r<16;r+=1)u[r]=909522486^o[r],c[r]=1549556828^o[r];return e=i(u.concat(h(t)),512+8*t.length),a(i(c.concat(e),640))}(r(n),r(t))}
        function t(n,t,r){return t?r?u(t,n):e(u(t,n)):r?o(n):e(o(n))}
        "function"==typeof define&&define.amd?define(function(){return t}):"object"==typeof module&&module.exports?module.exports=t:n.md5=t;
    }(this);
</script>


<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '60d1e67a466b7af7add7',
    clientSecret: '7e64b888991fafb9802cd7551bba4ac683fd3273',
    repo: 'm1crofan.github.io',
    owner: 'm1crofan',
    admin: ['m1crofan'],
    id: md5(location.pathname),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false       // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  钢琴 住了几个妖~嘿嘿！ 邮箱 煮了几个馍~ 嘚嘚！
  <a class="rss" href="https://m1crofan.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
